<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Alan Interactive Documentation</title>

    <!-- Custom HTML head -->
    

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    
        <link rel="stylesheet" href="css/solarized-light-hljs.css">
    
        <link rel="stylesheet" href="css/solarized-dark-hljs.css">
    

    
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "solarized-dark" : "solarized-light";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) { }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.add(default_theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="about_alan.html"><strong aria-hidden="true">1.</strong> About alan</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="language_reference.html"><strong aria-hidden="true">3.</strong> Language Reference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="structure_and_notation.html"><strong aria-hidden="true">3.1.</strong> Structure and Notation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="file_structure.html"><strong aria-hidden="true">3.1.1.</strong> File Structure</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope.html"><strong aria-hidden="true">3.1.1.1.</strong> Implied Structure: Scope</a></li><li class="chapter-item "><a href="imports.html"><strong aria-hidden="true">3.1.1.2.</strong> Imports</a></li><li class="chapter-item "><a href="types.html"><strong aria-hidden="true">3.1.1.3.</strong> Types</a></li><li class="chapter-item "><a href="constants.html"><strong aria-hidden="true">3.1.1.4.</strong> Constants</a></li><li class="chapter-item "><a href="events.html"><strong aria-hidden="true">3.1.1.5.</strong> Events</a></li><li class="chapter-item "><a href="functions.html"><strong aria-hidden="true">3.1.1.6.</strong> Functions</a></li><li class="chapter-item "><a href="operators.html"><strong aria-hidden="true">3.1.1.7.</strong> Operators</a></li><li class="chapter-item "><a href="statements.html"><strong aria-hidden="true">3.1.1.8.</strong> Statements</a></li><li class="chapter-item "><a href="interfaces.html"><strong aria-hidden="true">3.1.1.9.</strong> Interfaces</a></li><li class="chapter-item "><a href="handlers.html"><strong aria-hidden="true">3.1.1.10.</strong> Handlers</a></li><li class="chapter-item "><a href="exports.html"><strong aria-hidden="true">3.1.1.11.</strong> Exports</a></li><li class="chapter-item "><a href="classes.html"><strong aria-hidden="true">3.1.1.12.</strong> Classes</a></li></ol></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">3.1.2.</strong> Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="module_definition.html"><strong aria-hidden="true">3.1.2.1.</strong> Definition</a></li><li class="chapter-item "><a href="module_resolution.html"><strong aria-hidden="true">3.1.2.2.</strong> Resolution</a></li><li class="chapter-item "><a href="module_acquisition.html"><strong aria-hidden="true">3.1.2.3.</strong> Acquisition</a></li><li class="chapter-item "><a href="module_testing.html"><strong aria-hidden="true">3.1.2.4.</strong> Testing and Mocking</a></li><li class="chapter-item "><a href="module_mutation.html"><strong aria-hidden="true">3.1.2.5.</strong> Mutation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="standard_library.html"><strong aria-hidden="true">3.2.</strong> Standard Library</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="built_ins.html"><strong aria-hidden="true">3.2.1.</strong> Built-ins</a></li><li class="chapter-item expanded "><a href="std_app.html"><strong aria-hidden="true">3.2.2.</strong> @std/app</a></li><li class="chapter-item expanded "><a href="std_trig.html"><strong aria-hidden="true">3.2.3.</strong> @std/trig</a></li><li class="chapter-item expanded "><a href="std_stats.html"><strong aria-hidden="true">3.2.4.</strong> @std/stats</a></li><li class="chapter-item expanded "><a href="std_http.html"><strong aria-hidden="true">3.2.5.</strong> @std/http</a></li><li class="chapter-item expanded "><a href="std_dht.html"><strong aria-hidden="true">3.2.6.</strong> @std/dht</a></li><li class="chapter-item expanded "><a href="std_datastore.html"><strong aria-hidden="true">3.2.7.</strong> @std/datastore</a></li><li class="chapter-item expanded "><a href="std_logger.html"><strong aria-hidden="true">3.2.8.</strong> @std/logger</a></li><li class="chapter-item expanded "><a href="std_tcp.html"><strong aria-hidden="true">3.2.9.</strong> @std/tcp</a></li><li class="chapter-item expanded "><a href="std_udp.html"><strong aria-hidden="true">3.2.10.</strong> @std/udp</a></li><li class="chapter-item expanded "><a href="alantech_postgres.html"><strong aria-hidden="true">3.2.11.</strong> @alantech/postgres</a></li><li class="chapter-item expanded "><a href="std_test.html"><strong aria-hidden="true">3.2.12.</strong> @std/test</a></li><li class="chapter-item expanded "><a href="std_fs.html"><strong aria-hidden="true">3.2.13.</strong> @std/fs</a></li><li class="chapter-item expanded "><a href="std_csv.html"><strong aria-hidden="true">3.2.14.</strong> @std/csv</a></li><li class="chapter-item expanded "><a href="std_json.html"><strong aria-hidden="true">3.2.15.</strong> @std/json</a></li><li class="chapter-item expanded "><a href="std_xml.html"><strong aria-hidden="true">3.2.16.</strong> @std/xml</a></li><li class="chapter-item expanded "><a href="std_html.html"><strong aria-hidden="true">3.2.17.</strong> @std/html</a></li><li class="chapter-item expanded "><a href="std_css.html"><strong aria-hidden="true">3.2.18.</strong> @std/css</a></li><li class="chapter-item expanded "><a href="std_zlib.html"><strong aria-hidden="true">3.2.19.</strong> @std/zlib</a></li><li class="chapter-item expanded "><a href="std_bz2.html"><strong aria-hidden="true">3.2.20.</strong> @std/bz2</a></li><li class="chapter-item expanded "><a href="std_lzma.html"><strong aria-hidden="true">3.2.21.</strong> @std/lzma</a></li><li class="chapter-item expanded "><a href="std_base64.html"><strong aria-hidden="true">3.2.22.</strong> @std/base64</a></li><li class="chapter-item expanded "><a href="std_hash.html"><strong aria-hidden="true">3.2.23.</strong> @std/hash</a></li><li class="chapter-item expanded "><a href="std_ssl.html"><strong aria-hidden="true">3.2.24.</strong> @std/ssl</a></li><li class="chapter-item expanded "><a href="alantech_auth.html"><strong aria-hidden="true">3.2.25.</strong> @alantech/auth</a></li><li class="chapter-item expanded "><a href="std_i18n.html"><strong aria-hidden="true">3.2.26.</strong> @std/i18n</a></li><li class="chapter-item expanded "><a href="alantech_graphql.html"><strong aria-hidden="true">3.2.27.</strong> @alantech/graphql</a></li><li class="chapter-item expanded "><a href="alantech_oauth2.html"><strong aria-hidden="true">3.2.28.</strong> @alantech/oauth2</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="examples_with_explanations.html"><strong aria-hidden="true">4.</strong> Examples with Explanations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="many_forms_hello_world.html"><strong aria-hidden="true">4.1.</strong> The many forms of &quot;Hello, World!&quot;</a></li><li class="chapter-item expanded "><a href="advanced_examples.html"><strong aria-hidden="true">4.2.</strong> More advanced examples</a></li></ol></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
        
        <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                
            </div>

            <h1 class="menu-title">Alan Interactive Documentation</h1>

            <div class="right-buttons">
                <a href="https://alan-lang.org" title="Home">
                    <i>Home</i>
                </a>
                <a href="https://alan-lang.org/blog.html" title="Blog">
                    <i>Blog</i>
                </a>
                <a href="https://github.com/alantech" title="Git repository" aria-label="Git repository">
                    <i id="git-repository-button" class="fa fa-github"></i>
                </a>
            </div>
        </div>

        
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
        

        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>
                <h1><a class="header" href="#about-alan" id="about-alan">About <code>alan</code></a></h1>
<p><code>alan</code> is meant to fit like a glove. Like a glove, it's meant to be familiar and obvious how to use and generally not restricting. But like a glove, it has a few restrictions at the edges that going without it wouldn't have. And also like a glove, <code>alan</code> lets you grasp at things that would otherwise hurt you if you tried. ;)</p>
<h2><a class="header" href="#alans-not-turing" id="alans-not-turing"><code>alan</code>'s not turing</a></h2>
<p>The <code>alan</code> programming language is a little bit different from most programming languages, in that it is intentionally not Turing-complete. Loops and recursion have been eliminated<sup class="footnote-reference"><a href="#1">1</a></sup> from the language. But this doesn't make it a dumb declarative thing like HTML or eBPF<sup class="footnote-reference"><a href="#2">2</a></sup>. Instead, substitutes for looping and recursion have been provided by the language that should cover all<sup class="footnote-reference"><a href="#3">3</a></sup> of your needs in a controlled way, such that it should be impossible<sup class="footnote-reference"><a href="#4">4</a></sup> to write code that doesn't halt.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Technically an escape hatch through the event loop has been left open for very awkward recursive calls. This does not impact the advantages of the runtime for the language, however, and can be useful if absolutely necessary, but please reach out if you feel the need to use it, as that means either you're doing something wrong, or there's something missing to the language that should be added.
<sup class="footnote-reference"><a href="#2">2</a></sup>: http://www.brendangregg.com/ebpf.html
<sup class="footnote-reference"><a href="#3">3</a></sup>: Again, there is an intentional escape hatch, but it should be considered an emergency-only usage.
<sup class="footnote-reference"><a href="#4">4</a></sup>: Assuming no bugs in the runtime and no mistakes in our reasoning. This hasn't been formally verified, so I may be wrong, but it doesn't appear that way after a lot of ad-hoc analysis.</p>
</div>
<p>What you get in return for accepting these hopefully minor restrictions is a language that can automatically scale to your workload without rewriting, ever. Since all code is guaranteed<sup class="footnote-reference"><a href="#5">5</a></sup> to halt, it is possible to predict its runtime, and therefore to decide which thread(s) on which machine(s)<sup class="footnote-reference"><a href="#6">6</a></sup> should execute any particular part of it.</p>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p>Guarantees not guaranteed! ;)
<sup class="footnote-reference"><a href="#6">6</a></sup>: This will only be available from the proprietary SaaS service at first, and eventually a proprietary enterprise compiler will be available to license once less-predictable datacenters are handled by the runtime. The open source runtime will only decide which threads to use for any given task, making it more like Go, but with less insulting assumptions that developers are idiots.</p>
</div>
<p>It's not likely that <code>alan</code> will beat an experienced software architect in finding the absolute best cluster design for a given problem, but it will do a good job on all problems and not cause headaches when attempting to refactor that a large, rigid structure like that would entail. It's also likely that <code>alan</code> can't beat an experienced software architect <em>yet</em>, just like early compilers could not generate optimal assembly that those with years of experience writing assembly directly could, but eventually the compilers caught up for all but particular corner-cases and thus only rarely relevant today.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This definitely needs to be reworked. Copied from the old documentation. Not going to rework until we have this story completely straightened out, though.</p>
<h2><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h2>
<p>This project depends on <code>gradle</code> and <code>antlr v4</code> and is being developed on a Debian-based Linux distribution. To install the necessary dependencies, run:</p>
<pre><code>&gt; apt install gradle antlr4
</code></pre>
<p>If you wish to build the documentation, you also need <code>pandoc</code> and <code>xelatex</code>, and a simple:</p>
<pre><code>&gt; apt install pandoc texlive-xetex
</code></pre>
<p>should work.</p>
<h2><a class="header" href="#build" id="build">Build</a></h2>
<p>Once the dependencies are installed, simply run:</p>
<pre><code>&gt; gradle build
</code></pre>
<p>To build the project.</p>
<p>For the documentation, run:</p>
<pre><code>&gt; gradle docs
</code></pre>
<h2><a class="header" href="#install" id="install">Install</a></h2>
<p>Once the project is built, you can run:</p>
<pre><code>&gt; sudo gradle install
</code></pre>
<p>to install <code>alan</code>.</p>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>To use the interpreter, use the <code>alan</code> command. It has two sub-commands at this moment <code>run</code> and <code>debug</code>, plus <code>help</code> to tell you this. The <code>debug</code> command prints out metadata about the file in question, how it tokenized and parsed the context, useful only while developing the language itself. Most usage is through the <code>run</code> sub-command, like so:</p>
<pre><code>&gt; alan run examples/hello_world.ln
</code></pre>
<h1><a class="header" href="#language-reference" id="language-reference">Language Reference</a></h1>
<p>To understand <code>alan</code>, we will first go through the syntactic building blocks of the language using example fragments of code (since the grammar is still in flux, it can be referenced in the <code>src/main/antlr/Lang.g4</code> file for those interested. Once solidified, snippets from that file will be backported here). Afterwards, a reference of all of the built-in functionality and libraries will be listed.</p>
<h2><a class="header" href="#structure-and-notation" id="structure-and-notation">Structure and Notation</a></h2>
<p>The high level structure of <code>alan</code> is a collection of modules that perform particular functions, which execution being triggered by events causing their handlers to be run. Languages with module systems tend to scope either at the directory level or the file level. <code>alan</code> chooses to use file-level scoping, as anything not obvious to someone with a moderate familiarity with the language must be explicitly declared within the single file, instead of potentially being declared in sibling files.</p>
<h3><a class="header" href="#file-structure" id="file-structure">File structure</a></h3>
<p>Every <code>alan</code> file is made up of two parts, the <code>imports</code> and <code>body</code>. In <code>alan</code> all imports must be declared at the beginning of the file, and once anything else is declared <code>imports</code> are no longer allowed.</p>
<p>The <code>body</code> is simply everything else that can be declared in the file: <code>types</code>, <code>constants</code>, <code>functions</code>, <code>operators</code>, <code>events</code>, and <code>event handlers</code>. Of these everything but <code>event handlers</code> can be <code>exports</code> that can be used by other modules, even things simply imported from another module. These two levels of &quot;visibility&quot; in the file are part of an implied structure: scope.</p>
<h4><a class="header" href="#implied-structure-scope" id="implied-structure-scope">Implied Structure: Scope</a></h4>
<p>Scoping is a concept common in many programming languages, it is a way to determine what is available for use in your code or not, and can be thought of as a tree of maps you can check for a specified name<sup class="footnote-reference"><a href="#7">1</a></sup>. Module-less languages like C have a single primary scope defined across the entire project (as all source files are simply concatenated together) while functions and blocks<sup class="footnote-reference"><a href="#8">2</a></sup> have their own nested scopes.</p>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">1</sup>
<p>This is, in fact, exactly how the interpreter implements scopes.
<sup class="footnote-reference"><a href="#8">2</a></sup>: For those who don't know what blocks are, they are the inner bodies of if statements, while/for loops, etc in C, Java, Javascript, Python, etc, and usually surrounded by curly braces. For those who still don't know and must live in some parallel universe where LISP won, they're like immediately-invoked function expressions (IIFEs), and this is exactly how <code>alan</code> implements that concept under the hood.</p>
</div>
<p>Module-based languages tend to have two scopes per module, the private module-level scope and the public export scope. Java allows only a single exported element per file (but multiple files per module, remember) declared <code>public</code> while private elements are simply left undeclared. Node.js, Python, etc all have this two scope set for each module.</p>
<p><code>alan</code> continues that tradition here for ease of use, and like many of the languages does have a wholly-internal root scope that built-in types, functions, etc are defined in that all scopes eventually inherit from.<sup class="footnote-reference"><a href="#9">3</a></sup></p>
<div class="footnote-definition" id="9"><sup class="footnote-definition-label">3</sup>
<p>The &quot;Built-Ins&quot; section below is essentially documentation of this root scope and what it automatically brings to every module.</p>
</div>
<p>TODO: Add some diagrams of scope as different nested sets via Venn diagrams.</p>
<h4><a class="header" href="#imports" id="imports">Imports</a></h4>
<p>To import the exports of other modules, <code>alan</code> provides two different syntaxes to select the exports to import. There are also two different syntaxes to identify the module you wish to import from. These two syntaxes are completely interchangeable leading to four different syntactic combinations. This sounds more complicated than it actually is.</p>
<h5><a class="header" href="#identifying-modules" id="identifying-modules">Identifying Modules</a></h5>
<p>Let's start with the module identifying syntax. That would be either:</p>
<pre><code>./some/module
</code></pre>
<p>or:</p>
<pre><code>@some/module
</code></pre>
<p>The first form begins with a <code>./</code> or a <code>../</code> and is a <code>relative import</code>. It simply traverses your filesystem and looks for the appropriate module, which would be named either <code>./some/module.ln</code> or <code>./some/module/index.ln</code>. The latter allows for simplifying transitions if a module has grown too big to be a single file, anymore, or for more advanced module mocking/intercepting that will be covered in more depth in the Modules section below.</p>
<p>The second form begins with an <code>@</code> and is a <code>named import</code>. It uses a more advanced search pattern, searching the current directory and up recursively in the <code>modules</code> and <code>dependencies</code> directories for the specified module, where the module name at that point otherwise matches the relative path, so translated to <code>relative</code> it could look something like: <code>./modules/some/module.ln</code> or <code>../../dependencies/some/module/index.ln</code>.</p>
<p>The second form is useful for referencing third-party code and your own code that is a cross-cutting concern for many modules in your project, like a custom logging wrapper module. Placing these files in a root-level <code>modules</code> directory can let you easily reference them everywhere without needing to worry about where you currently are in the directory hierarchy and without needing to maintain it as a separate library in a separate repository and then published and available in a module registry (public or private) and then installed through the language package manager and updated after every update to the  as is the case if you want the same benefits in Node, Ruby, Python, etc.</p>
<h5><a class="header" href="#importing-modules" id="importing-modules">Importing Modules</a></h5>
<p>Once you've identified the module you want to import, now it's time to decide how you want to import it. There's the basic scoped import and the &quot;plucking&quot; unscoped import. These syntaxes are essentially lifted wholesale from Python:</p>
<pre><code>import @std/http
import ./my/module as myModule
from @std/app import start, print as println, exit
</code></pre>
<p>Simply stating <code>import ./some/module</code> will automatically create a new variable named &quot;module&quot; (the text after the last slash, or after the <code>@</code> if no slashes at all).</p>
<p>The exported items are accessible with the conventional dot notation, like <code>module.someFunction()</code>.</p>
<p>Sometimes the automatically-generated import name is going to alias another module, or sometimes you just don't think it's a descriptive name, so you have the option to rename it within your module using the <code>as newName</code> syntax.</p>
<p>If you write <code>from ./some/module import var1, var2, ...</code> you will pull the exported variable directly out of the export scope and place it within your module scope with that name, and you also have the option to ue the <code>as newName</code> syntax on any of these imports, as well.</p>
<p>That's it.</p>
<p>Those with experience in other module-based languages may be wondering where the <code>*</code> syntax is. That has been intentionally left out. It makes reading your own module more difficult as it can be unclear, especially when there are multiple <code>*</code> imports, where a specified name came from.</p>
<p>The general effect of <code>*</code> imports (not needing to adjust the import statement when new features are added) can be achieved by using the scoped import form.</p>
<p>The advantage to those new to the language is immediate: <em>anything</em> they see in a module that is not explicitly defined was defined by the language, either as syntax or a built-in function/type/operator/etc, which will make looking up unknowns more fruitful for these users, and forces an explicit lookup location that's still useful for more advanced users.</p>
<h4><a class="header" href="#types" id="types">Types</a></h4>
<p>There are two major categories of types in <code>alan</code>: built-in types and user-defined types. User-defined types are similar to <code>struct</code>s in C as they are simply named compound types made up of other user-defined types or built-in types.</p>
<p>Built-in types also divide into a few categories: basic types, strings, and special types.</p>
<h5><a class="header" href="#basic-types" id="basic-types">Basic Types</a></h5>
<p>Basic types include integers (<code>int8</code>, <code>int16</code>, <code>int32</code>, and <code>int64</code>), floating point numbers (<code>float32</code> and <code>float64</code>), booleans (<code>bool</code>), and the <code>void</code> (no value) type. The numbers refer to the number of bits consumed by the basic type, and because of the limitations of the JVM, there are no unsigned variants (it's possible, but it'll be difficult and slow -- I'll eventually have to fix this, but I'm hoping I can do it by just rewriting on top of LLVM when the actual compiler gets started).</p>
<p>The basic types all have in-line constant representations.</p>
<p>The integers have basic base-10 integer form as well as hexadecimal form supported right now. Eventually binary and octal will also be supported but that is not yet implemented.</p>
<p>The floating point numbers have only basic base-10 with a decimal point form, no scientific notation form yet, but that will also be implemented in the future.</p>
<p>Booleans are represented by the keywords <code>true</code> and <code>false</code>. <code>void</code> has no representation beyond <code>void</code>. It can't be assigned to, and is meant to represent when functions return nothing.</p>
<p>The basic types are included in the root scope and never need to be explicitly defined, they always exist.</p>
<h5><a class="header" href="#strings" id="strings">Strings</a></h5>
<p>Strings (<code>string</code>) are a bit beyond the basic type. Traditionally they can be thought of as a byte array, but UTF codepoints make that representation not manageable. From the perspective of the user of <code>alan</code> they are <code>utf-8</code> codepoints (as that is what the parser reads the files as), from the perspective of the <code>alan</code> interpreter they are <code>utf-16</code> codepoints, and from the perspective of conversion of the string into bytes, that is undefined because I haven't built that yet. ;)</p>
<p>Strings are defined by wrapping double or single quotes (<code>&quot;</code> or <code>'</code>) around text. Right now they are very primitive and don't understand escape codes so it is impossible to define a string that uses both single and double quotes internally, along with unprintable characters, but based on my reading of the parser they should handle multi-line strings just fine? All of this is subject to change as the parser and interpreter (and eventually compiler) are polished up.</p>
<p>Strings are also included in the root scope and never need to be explicitly defined.</p>
<h5><a class="header" href="#user-defined-types" id="user-defined-types">User-Defined Types</a></h5>
<p>User-defined types must be declared by the user (er, duh?), and they follow the following syntax:</p>
<pre><code>type typename {
  propertyName: propertyType
  otherProperty: otherType
}
</code></pre>
<p>There is currently no syntax to define a user-defined type constant (so they can't be used as constants, yet), but the intended syntax that will eventually be implemented looks like the following:</p>
<pre><code>const myVal: typename = new typename {
  propertyName: propertyValue
  otherProperty: otherValue
}
</code></pre>
<p>The redundant <code>typename</code> in that example will also eventually be eliminated by type inference, reducing it to just:</p>
<pre><code>const myVal = new typename {
  propertyName: propertyValue
  otherProperty: otherValue
}
</code></pre>
<p>User-defined types have another interesting feature: they can be generic. That means one or more of the actual sub-types used by the type is not yet defined, but will be &quot;solidified&quot; later on with the creation of a new type based on it.</p>
<p>Generic types look like this:</p>
<pre><code>type typename&lt;A, B&gt; {
  propertyName: A
  otherProperty: B
}
</code></pre>
<p>Where later on you can &quot;solidify&quot; that type either by creating an alias with the types filled in:</p>
<pre><code>type typenameIntStr = typename&lt;int64, string&gt;
</code></pre>
<p>or just declaring a variable that uses a &quot;solidified&quot; type:</p>
<pre><code>let myVar: typename&lt;bool, float64&gt;
</code></pre>
<p>However, until interfaces are implemented, you cannot write functions that operate on generic types, because there is no guarantee that the type it solidifies into has the necessary primitives to operate on, so generic types are mostly an oddity used to make the special types possible until that is added.</p>
<h5><a class="header" href="#special-types-arrays-maps-and-trees-and-sets" id="special-types-arrays-maps-and-trees-and-sets">Special Types: Arrays, Maps, and Trees (and Sets?)</a></h5>
<p>In a language with no looping or recursion, every function has a predictable runtime, but they also can't do very much, as evidenced by the limited utility of eBPF (but also the lack of an issue with it running in kernel-space). It is essentially impossible to implement any real computing algorithms yourself.</p>
<p>But if there were the right built-in primitives with the right built-in functionality, you could combine them to create the algorithms you need without the looping construct. This is the purpose of the special types, Arrays, Maps, and Trees. They are special-cased generic types that come with built-in functions to perform all of the various transforms one would want, taking functions to perform the tasks.</p>
<p><code>Array&lt;V&gt;</code>, <code>Tree&lt;V&gt;</code>, (and <code>Set&lt;V&gt;</code>) are singly-generic while <code>Map&lt;K, V&gt;</code> has two generic types. They function almost identically to the built-in generic types from Java of a similar name, but it is <code>alan</code>'s job to determine the correct way to realize them: whether the <code>Array</code> is a <code>LinkedList</code> or <code>ArrayList</code> (hint: it's gonna be a hybrid, but mostly <code>ArrayList</code>), and whether to shard the data across threads to run in parallel or just stick with sequential because the scatter-gather synchronization costs are too high.</p>
<p>Still working on this part, but it's what will make the language bearable, and coming from JavaScript will likely not impact your idiomatic style much at all.</p>
<h4><a class="header" href="#constants" id="constants">Constants</a></h4>
<p>Constants are one of the two things that can be defined in both the module scope and a function scope (the other being more functions). The syntax is simply:</p>
<pre><code>const varname: typename = constvalue
</code></pre>
<p>where typename must be an existing type and the <code>constvalue</code> must be replaced with a number, boolean, string, etc. (Actually no etc, yet, as user-defined types can't be defined as a constant, yet, but that will change!)</p>
<h4><a class="header" href="#events" id="events">Events</a></h4>
<p>Events are sources for activity in <code>alan</code>. No code is run that isn't triggered by an event. Event declaration is relatively simple:</p>
<pre><code>event eventName: typename
</code></pre>
<p>where <code>eventName</code> is the name of the event. It is also possible to construct an event with a function if the set of possible events to work with is difficult to describe statically. A function that returns an instance of a realized <code>Event&lt;E&gt;</code> type can also be used to emit to or register a handler for. Since event handler registration can only happen in module scope, this is more of a macro-like expansion and the total set of event types in the system is still known statically to the compiler. See the HTTP Server example near the end of this document for more information.</p>
<h4><a class="header" href="#functions" id="functions">Functions</a></h4>
<p>Functions are where actual work happens. There are built-in functions and user-defined functions. The user-defined functions consist of a sequence of statements composing other functions, operators, types, etc.</p>
<h5><a class="header" href="#function-declarations" id="function-declarations">Function Declarations</a></h5>
<p>Declaration of functions works like so:</p>
<pre><code>fn functionName (firstArgument: argumentType, secondArgument: anotherType): returnType {
  ...statements...
}
</code></pre>
<p>This is a named function with a name, some arguments, and a return type.</p>
<pre><code>fn functionName (firstArgument: argumentType, secondArgument: anotherType): void {
  ...statements...
}
</code></pre>
<p>This is a named function that does not return any value.</p>
<pre><code>fn functionName (): returnType {
  ... statements...
}
</code></pre>
<p>This is a named function that takes no arguments but returns a value.</p>
<pre><code>fn functionName {
  ...statements...
}
</code></pre>
<p>This is a named function that takes no arguments and returns no value. (So side-effects only.)</p>
<pre><code>const anonymousFunction = fn (firstArg: argType, secondArg: anotherType): returnType {
  ...statements...
}
</code></pre>
<p>This is an anonymous function that takes arguments and returns a value. Anonymous functions can only be assigned to variables or immediately passed to other syntax that takes a function (event handlers, conditionals, or as an argument to another function).</p>
<pre><code>const anonymousArglessFunction = fn (): returnType {
  ...statements...
</code></pre>
<p>This is an anonymous function that takes no arguments and returns a value.</p>
<pre><code>const anonymousSideEffectFunction = fn {
  ...statements...
</code></pre>
<p>This is an anonymous function that takes no arguments and returns no value (side-effect only).</p>
<pre><code>on eventname {
  ...statements...
}
</code></pre>
<p>When an anonymous, argumentless, no-return function is defined inline with event handlers or conditionals, it is unambiguous to omit the <code>fn</code> so it is allowed in these conditions.</p>
<h5><a class="header" href="#function-dispatch" id="function-dispatch">Function Dispatch</a></h5>
<p>When determining which function to use in a function call (more on calls later), the argument types and count are taken into consideration. Multiple functions with the same name may be declared as long as the argument types and/or counts are different between them. For example:</p>
<pre><code>fn someFn (arg1: string, arg2: bool): string {
  ...
}

fn someFn (arg1: int64, arg2: bool): int64 {
  ...
}
</code></pre>
<p>If you provide a <code>string</code> to <code>someFn</code> it will use the first definition, and if provided an <code>int64</code> it will use the second.</p>
<p>This means it is possible to alias/replace even built-in functions within your module scope. <strong>This is dangerous.</strong> If you are not aware that, for instance, the <code>+</code> operator is also called <code>add</code> as a function, and define your own <code>add</code> function that works on numbers, you'll find things are very broken. I think I will add warnings or errors on aliasing built-in functions (where the original can no longer be accessed because it perfectly matches the type signatures), but currently you're on your own here.</p>
<h5><a class="header" href="#function--arity" id="function--arity">Function -arity</a></h5>
<p><code>alan</code>'s interpreter has the ability to use functions with <code>n</code>-arity, functions where the last argument is actually treated as an array of an arbitrary length of the same type. This is used to implement the <code>concat</code> built-in function, allowing an arbitrary number of <code>string</code>s to be concatenated together. The syntax in the language does not allow that <em>yet</em> as it depends on the <code>Array</code> special type to be fully functional, first. Eventually, the expected syntax will look something like this:</p>
<pre><code>fn narityFunction(arg1: type1, ...arg2: Array&lt;type2&gt;): returnType {
  ...statements...
}
</code></pre>
<p>where the last argument is allowed to have the <code>...</code> syntax to indicate that the function should expect 0 or more of these elements in the call and automatically box them into an array of that type (or if the last element provided <em>is</em> an array of that type, just use it as-is).</p>
<h5><a class="header" href="#function-type" id="function-type">Function Type</a></h5>
<p>A function's type is simply <code>function</code> right now. It is intended to expand this to use a syntax allowing more precise argument matching when passing functions to higher-order functions, so the user can know what arguments and return type their function is expected to have. This type syntax would look like:</p>
<pre><code>(firstType, secondType): returnType
</code></pre>
<p>Essentially the argument list with only the types specified and the return type. In this case, the parenthesis and <code>void</code> would be required to prevent ambiguity (and keep it easier to follow), so a side-effect-only function type would look like this:</p>
<pre><code>(): void
</code></pre>
<p>Because type names are specified in very specific situations, the extra colon and space in the type name should not be unambiguous to the interpreter.</p>
<h5><a class="header" href="#function-calls" id="function-calls">Function Calls</a></h5>
<p>One of the kinds of statements you can write inside of a function is a function call. There are actually two syntaxes for function calls, standard form and method form.</p>
<p>Standard form looks like this:</p>
<pre><code>add(3, 2)
</code></pre>
<p>while method form looks like this:</p>
<pre><code>3.add(2)
</code></pre>
<p>Method form allows you to pull the first argument out of the function and treat the function call like an Object-Oriented Language's method syntax. This allows method chaining, which can be much more legible when the output of one function is the input of the next, without requiring a custom chaining syntax that some functional languages have adopted (eg <code>|&gt;</code> in F#). Eg, <code>3.add(2).mul(5).mod(3)</code> is equivalent to <code>mod(mul(add(3, 2), 5), 3)</code>.</p>
<h4><a class="header" href="#operators" id="operators">Operators</a></h4>
<p>In <code>alan</code>, operators are just a special form of function.</p>
<p>All operators are made up of only the symbols: <code>+, -, /, *, ^, ., ~, `, !, @, #, $, %, &amp;, |, :, ;, &lt;, &gt;, ?, =</code> (excluding the commas used to separate them from each other, they are reserved for list separators only).</p>
<p>Operators have operator precedence to determine how they are implicitly grouped by parenthesis.</p>
<p>Any exported operator <em>must</em> also export its implementing functions, so users can choose to use the more descriptive function names instead of the terse-but-cryptic operator symbols.</p>
<p>Operators have only two forms: prefix operators that take only one argument and infix (in-between) operators that take two arguments.</p>
<p>Prefix:</p>
<pre><code>&lt;operator&gt; argument
</code></pre>
<p>Infix:</p>
<pre><code>argument1 &lt;operator&gt; argument2
</code></pre>
<p>Infix operators can also be declared to be commutative or associative (or neither). This can allow certain built-in functions to automatically determine how much parallelism is safe with the provided operator.</p>
<p>The syntax to define a prefix operator looks like this:</p>
<pre><code>prefix &lt;operatorSymbol&gt; &lt;precedenceNumber&gt; functionName
</code></pre>
<p>where <code>&lt;operatorSymbol&gt;</code> is some combination of the symbols listed above (with a special ban on a solitary <code>=</code> as that is already used for assignment) and <code>&lt;precedenceNumber&gt;</code> is an <code>int8</code> number (<code>(-128, 127)</code> inclusive) indicating the precedence level, with a larger number taking precedence over a smaller one. Only the numbers <code>0 - 4</code> are used by any built-in operator, and the <code>functionName</code> being the function to map to the prefix. Only functions with that name with a single argument will be considered (or n-arity functions where the first argument is also the &quot;last&quot;, once n-arity support is added).</p>
<p>The syntax to define infix operators is similar, and looks like this:</p>
<pre><code>infix [commutative] [associative] &lt;operatorSymbol&gt; &lt;precedenceNumber&gt; functionName
</code></pre>
<p>where <code>[commutative]</code> is either the <code>commutative</code> keyword or blank, <code>[associative]</code> is the <code>associative</code> keyword or blank, <code>&lt;operatorSymbol&gt;</code> is the symbol for the operator, <code>&lt;precedenceNumber&gt;</code> is an <code>int8</code> number, and <code>functionName</code> is the function being mapped to the operator. Only functions with two arguments will be considered.</p>
<p>The example earlier of the function calls <code>3.add(2).mul(5).mod(3)</code> / <code>mod(mul(add(3, 2), 5, 3)</code> can be written with operators as <code>(3 + 2) * 5 % 3</code> or <code>5 * (3 + 2) % 5</code>, where the parenthesis break the operator precedence to allow addition to come first. See the built-in operators section below for the list of built-in operators and an operator precedence table.</p>
<h4><a class="header" href="#statements" id="statements">Statements</a></h4>
<p>Within a function are multiple statements. The order of the statements defines their dependence on one another based on what they manipulate in their scope hierarchy. Currently the interpreter simply runs them sequentially, but soon (tm) it will use the scope manipulation to determine a dependency graph of the statements to determine running order without impacting the result (which will also allow multiple threads to be used to run a single function call if there is a performance advantage to doing so).</p>
<p>Statements must be on different lines, but statements can span multiple lines, as well. There are six types of statements: variable declarations, variable assignments, function calls, function returns, event emission, and conditionals (if statements).</p>
<h5><a class="header" href="#variable-declarations" id="variable-declarations">Variable Declarations</a></h5>
<p>There are two types of variables, constants and mutable variables. Constants are declared with these two syntaxes:</p>
<pre><code>const varname: typename = constantOrFunctionCallOrExpression
const varname = constantOrFunctionCallOrExpression
</code></pre>
<p>The typename is optional as it can be inferred from the value being assigned. Providing the type can be useful to make sure your code is doing what you expected, though, and not using an unexpected type. By default all numeric constants are automatically the highest definition version possible. (<code>int64</code> or <code>float64</code>)</p>
<p>Any type that exists in the language can be assigned. Simple constants are simply declared, or produced via function calls or operator expressions. User-defined types can be assigned to constants through the use of a constructor function and calling it, through an expression involving operators that produces the user-defined type, or through the user-type literal syntax. Arrays and Maps have similar but slightly different syntaxes, as they deal with inherently plural data versus the struct-like user-defined types:</p>
<pre><code>const simpleConstant: bool = true
const simpleConstant2 = &quot;simple&quot;
const expressionResult: int64 = 3 + 5 * 2 + fnCall2(3, 1)
const fnResult: someType = functioncall(3, 5)
const userTypeLiteral = new UserType {
  key = &quot;val&quot;
  foo = true
  bar = 3
}
const arrayTypeLiteral = new Array&lt;int64&gt; [ 1, 1, 2, 3, 5, 8, 13 ]
const mapTypeLiteral = new Map&lt;bool, string&gt; {
  true: &quot;It's true!&quot;
  false: &quot;Nuh uh!&quot;
}
</code></pre>
<p>All three complex type literals begin with the <code>new</code> keyword, followed by the type name, which must be a realized generic if it is a generic type. If the original generic type was an <code>Array</code> or <code>Map</code> it gets a special syntax. Arrays are surrounded by brackets (<code>[</code>, <code>]</code>) instead of curly braces (<code>{</code>, <code>}</code>) and are simply a comma-delimited list of values (they could also be generated by functions or operator expressions, or be a user-defined type literal). Maps are keep the curly braces, but the <code>key</code> and <code>value</code> pairs are separated by a colon (<code>:</code>) instead of an equal sign (<code>=</code>), which fits more closely to the Map/Object syntax popularized by JSON (but able to have more than just <code>string</code> values for the keys).</p>
<p>Beyond that, there is also the ability to assign the type name of another variable, but the constant <em>must</em> be a string in that case:</p>
<pre><code>const typename: string = type otherVariable
</code></pre>
<p>For mutable variables, there are three syntaxes:</p>
<pre><code>let varname: typename
let varname: typename = constantOrFunctionCallOrExpression 
let varname = constantOrFunctionCallOrExpression
</code></pre>
<p>The first syntax allows one to declare a variable without giving it any value (it will default to 0 or false or empty string, etc). The second syntax is identical to the constants syntax, but the first syntax <em>requires</em> the type to be declared as it would be unknown, otherwise.</p>
<h5><a class="header" href="#variable-assignments" id="variable-assignments">Variable Assignments</a></h5>
<p>This syntax only works with mutable variables:</p>
<pre><code>varname = constantOrFunctionCallOrExpression
varname.propertyName = constantOrFunctionCallOrExpression
varname[integerOrMapKey] = constantOrFunctionCallOrExpression
</code></pre>
<p>Since the variable type is already known, it is no longer included. Anything that could be assigned at declaration time is assignable in future assignments. When re-assigning to the properties of user-defined types, you use the dot notation. When re-assigning to <code>Array</code>s or <code>Map</code>s, you use the array-accessor notation.</p>
<h5><a class="header" href="#function-calls-1" id="function-calls-1">Function Calls</a></h5>
<p>Because functions can have side effects that might be desirable, and functions defined within the scope of the current function could potentially mutate multiple variables, and so on, it's allowed to call them without storing a return value. It simply looks like this:</p>
<pre><code>someFunction(arg1, arg2)
</code></pre>
<p>where the arguments themselves could be constants, variable names, other function calls, operator statements, and variable type selection.</p>
<h5><a class="header" href="#function-returns" id="function-returns">Function Returns</a></h5>
<p>A return statement sets the value of the return type for the function and ends execution:</p>
<pre><code>return constantOrFunctionCallOrExpression
</code></pre>
<p>If the function has no return value, you can also trigger an exit without assigning a return value by simply stating:</p>
<pre><code>return
</code></pre>
<h5><a class="header" href="#event-emission" id="event-emission">Event Emission</a></h5>
<p>A function can trigger new events to occur by emitting one:</p>
<pre><code>emit eventName
emit eventName constantOrFunctionCallOrExpression
</code></pre>
<p>If the event is a void event (no arguments given to the handler functions) then you use the simple first syntax. If there is a value provided to the handler, then as with the other statements it could be a constant or variable name or function call or operator expression or type name of a variable that is provided.</p>
<h5><a class="header" href="#conditionals" id="conditionals">Conditionals</a></h5>
<p>Conditionals optionally run one block of code (or potentially another) based on a condition. Since this language is intended to run statements in dependency order, the scope the conditions run in are actually functions to prevent them from being run ahead of time. This also means all scopes once you enter a function scope are function scopes, which makes things simpler to reason about. If one of these functions returns a value, the outer function immediately returns that value from the conditional statement.</p>
<p>The conditional syntax is:</p>
<pre><code>if booleanConstantOrFunctionCallOrExpression thenFunction
if booleanConstantOrFunctionCallOrExpression thenFunction else elseFunction
if booleanConstantOrFunctionCallOrExpression thenFunction else if ...
</code></pre>
<p>where the constant, function call, or operational expression <em>must</em> evaluate to a boolean (so no type checking, unless it is within an equality check against an expected type name).</p>
<p>Conditionals are one of the two places (the other being event handler declarations) where the <code>fn</code> may be omitted from a purely-side-effect function (no arguments, no return value), so the above can look exactly as one would expect:</p>
<pre><code>if 1 == 2 {
  print(&quot;Wrong&quot;)
} else {
  print(&quot;Right&quot;)
}
</code></pre>
<p>The conditional has two anonymous functions declared inline. But it could just as easily be something like:</p>
<pre><code>fn right() {
  print(&quot;Right&quot;)
}

fn wrong() {
  print(&quot;Wrong&quot;)
}

const condition: bool = 1 != 2

if condition right else wrong
</code></pre>
<h4><a class="header" href="#interfaces" id="interfaces">Interfaces</a></h4>
<p>In order to make generic types more useful, there must be a way to declare what operations/functions are possible to apply to the generic type in question so functions working with said generic are able to be checked even if the generic function is not &quot;solidified&quot; (for example, it is an exported library meant to be used by other code). Interfaces are the proposed solution, and they'll look something like this:</p>
<pre><code>interface interfaceName {
  functionname (concreteType, interfaceName): concreteType
  function2 (interfaceName, interfaceName): interfaceName
  interfaceName &lt;operatorSymbol&gt; interfaceName: interfaceName
  &lt;operatorSymbol2&gt; interfaceName: concreteType
  potentialPropertyName: concreteType
  potentialPropertyName2: concreteType
}
</code></pre>
<p>They declare which functions and/or operators must exist for the type to pass the interface and provide a guarantee to the function using that interface which functions and/or operators are available for use within the function body. Because function dispatch is based on the input arguments and not the output type, at least one of the input arguments <strong>must</strong> be <code>interfaceName</code>. They can also optionally declare certain properties with certain concrete types as being required to exist. This would only make sense for the user-defined types, but it appears useful for them to prevent requiring useless accessor functions to be written.</p>
<p>Within a function, the interface name simply substitutes for a type and is used in place of it, with the function/operator usage being checked against the interface instead of the scope. When usage of the function comes later, the type and functions/operators that work with it are checked against the interface and the <em>current scope</em> to see if it is valid. This means that it is possible for a function using interfaces to work with a particular type in one module scope but not another based on what has been imported into each scope. It also means that the behavior of the function could change between modules if a <em>different, but matching</em> function is imported or declared in the relevant scope.</p>
<p>This is because invocation of the function in that scope also counts as definition of that function within the scope, with the original being used as a template for the function, and the current module's scope being injected between the export scope of the module it was pulled from (if it was imported across scope boundaries).</p>
<p>Coming Soon (tm) there will be a way to declare generic types within the <code>interface</code> to alias interfaces. This is to allow specification that two different arguments (or the return type) of a function can be the same interface, but should or should not resolve to the exact same type.</p>
<p>For example:</p>
<pre><code>interface Mappable {
  map(Array&lt;any&gt;, fn (any): any): Array&lt;any&gt;
}
</code></pre>
<p>provides no guarantees that the <code>any</code> in the first argument's <code>Array&lt;any&gt;</code> should also be the first <code>any</code> in the provided function declaration <code>fn (any): any</code>, while the second <code>any</code> in that function declaration does <em>not</em> need to match the first, but it <em>does</em> need to match the <code>any</code> in the return type of the <code>map</code> function.</p>
<p>To make this clear, this syntax is proposed (but not yet implemented):</p>
<pre><code>interface Mappable {
  type A as any
  type B as any
  map(Array&lt;A&gt;, fn (A): B): Array&lt;B&gt;
}
</code></pre>
<h4><a class="header" href="#handlers" id="handlers">Handlers</a></h4>
<p>Handlers are what are triggered by events emitted to the event loop. They are the functions that are at the root of all stacks in <code>alan</code>. Like many languages with event loops, multiple handlers can exist for a single event.</p>
<p>Event handler functions <em>must</em> always have a <code>void</code> return. From the perspective of the language, handlers are self-contained side-effects, because it is unclear where a returned value should even go.</p>
<p>Handlers can only be registered at the module level, not within a function. This is both to discourage abuse of the event loop and make sure that the potential workload on future events is knowable and known by all instances across a distributed cluster so execution planning can take that into consideration. </p>
<p>For example, once compiled, the list of event handlers would be a static, known value, with known execution time ranges for each, and then the size of the event loop queue can be considered when determining the execution plans: should it focus on event throughput at the expense of latency, or optimize for event processing latency if there are extra resources available? The interpreter in its current state does none of this, but this is why it is designed the way it is.</p>
<p>The event handler syntax is relatively simple:</p>
<pre><code>on eventName function
</code></pre>
<p>where <code>eventName</code> is the name of the event to register a handler for and <code>function</code> is either the name of a function, or an in-line defined function, eg:</p>
<pre><code>on event fn namedHandler(argument: eventType) {
  ...
}
</code></pre>
<p>for a fully-named in-line defined function with an event payload. Without a payload, the argument list can be dropped:</p>
<pre><code>on event fn namedHandler {
  ...
}
</code></pre>
<p>In both cases, the name is also optional because it is being registered immediately:</p>
<pre><code>on event fn (argument: eventType) {
  ...
}
</code></pre>
<p>or</p>
<pre><code>on event fn {
  ...
}
</code></pre>
<p>The latter purely-side-effect-only function can also omit the <code>fn</code> if desired as it is unambiguous in this context:</p>
<pre><code>on event {
  ...
}
</code></pre>
<h5><a class="header" href="#special-events-stdappstart-stdappexit-and-stdappstdout" id="special-events-stdappstart-stdappexit-and-stdappstdout">Special Events: @std/app.start, @std/app.exit, and @std/app.stdout</a></h5>
<p>There are events that are particularly special for <code>alan</code>. The <code>start</code>, <code>exit</code>, and <code>stdout</code> events in the <code>@std/app</code> standard library module. They are separated from the built-ins because most modules should not need to ever touch them, but the root module of your project will.</p>
<p>When <code>alan</code> has finished loading your code and has the event loop set up, it emits a single <code>start</code> event (of type <code>void</code>). That should trigger a special function used to set up the rest of your program: loading configuration, starting up an http server, or what have you.</p>
<p>Once the event loop is running, it will run forever. Only if an <code>int8</code> value (the exit code, where 0 is successful and anything else is an error) is emitted to the <code>exit</code> event will the process tear itself down and terminate.</p>
<p>If you want to write raw text to <code>stdout</code> you can <code>emit</code> to a string to it (this is what the <code>print</code> function does, but with an appended newline character after converting your argument to a string).</p>
<p>This is why basically all of the small examples import these events from <code>@std/app</code>, but most modules in most larger projects never will.</p>
<h4><a class="header" href="#exports" id="exports">Exports</a></h4>
<p>The <code>export</code> syntax can only be used at the module level, which means it is impossible to have non-deterministic exports. While this can be annoying with collating files that simply import files to only re-export all of their contents, it eliminates whole classes of ambiguity where certain functions, types, etc are only available depending on the state of the runtime environment.</p>
<p>Constants, types, functions, operators, events (and in the future interfaces and classes) are exportable while event handlers are not.</p>
<p>This can either be done in-line with the declaration of the item in question:</p>
<pre><code>export const foo: bool = true
</code></pre>
<p>Or it can be done by referncing the name of the thing to be exported after it has been declared:</p>
<pre><code>type Foo {
  bar: string
  baz: bool
}

export Foo
</code></pre>
<p>Both styles produce identical results: the exported item is accessible both within the module and by any other module that imports it.</p>
<h4><a class="header" href="#coming-soon-tm-classes" id="coming-soon-tm-classes">Coming Soon (tm): Classes</a></h4>
<p>In <code>alan</code>, classes are (will be) almost purely syntactic sugar. A class is a collection of fields in a type and methods to act on them. So that's what classes are in <code>alan</code>, syntactic sugar to define methods while skipping the first argument in the argument list (and automatically naming it <code>this</code>) for a type that is being defined.</p>
<p>The only extra bit that's not quite purely syntactic sugar would be the <code>constructor</code> function, which will need a bit of extra help to use.</p>
<p>A simple class like this:</p>
<pre><code>class Foo {
  bar: string
  baz: bool

  getBar(): string {
    return this.bar
  }

  bazzle(): string {
    if (this.baz) {
      return &quot;bazzle!&quot;
    } else {
      return &quot;buzzle...&quot;
    }
  }
}
</code></pre>
<p>Would directly translate to:</p>
<pre><code>type Foo {
  bar: string
  baz: bool
}

fn getBar(this: Foo): string {
  return this.bar
}

fn bazzle(this: Foo): string {
  if (this.baz) {
    return &quot;bazzle!&quot;
  } else {
    return &quot;buzzle...&quot;
  }
}
</code></pre>
<p>In this case, the number of lines of code is identical, though the class syntax is very slightly less typing and looks more familiar to people coming from OO languages. Those same people will be noticing that this direct translation from <code>class</code> to <code>type</code> means there cannot be private and protected properties and methods defined in the class. Two points:</p>
<ol>
<li>Methods can still be effectively private by not exporting them along with the rest of the class, but I would still discourage that, because:</li>
<li>Private properties of a class have always been a mistake. They assume that there is never going to be a valid use-case for anyone else to ever access them, so data serialization and deserialization, among other things, is made ridiculously hard in these OO languages, and they really come from a misguided attempt by language authors to obfuscate how their code works while calling it &quot;Encapsulation&quot;, as if you don't already have to deal with the allocated memory for it, deal with potential serialization/translation issues and repopulation issues if that internal state can't be created by the constructor.</li>
</ol>
<p><img src="./src/docs/im_right.jpg" alt="Why are you booing me? I'm right." /></p>
<p>However, I believe it would be possible to obfuscate certain properties by creating a special type with the private values and creating a special property (probably called <code>private</code>) and not exporting that type. I'm not sure if I want to treat that as a compiler error, though, because I'm right about trying to restrict data access.</p>
<p>As alluded to above, there are two ways that classes could be exported:</p>
<pre><code>export class Foo {
  bar: string
  baz: bool

  getBar(): string {
    return this.bar
  }

  bazzle(): string {
    if (this.baz) {
      return &quot;bazzle!&quot;
    } else {
      return &quot;buzzle...&quot;
    }
  }
}
</code></pre>
<p>which would export everything, the type and all of the defined methods, versus:</p>
<pre><code>class Foo {
  bar: string
  baz: bool

  getBar(): string {
    return this.bar
  }

  bazzle(): string {
    if (this.baz) {
      return &quot;bazzle!&quot;
    } else {
      return &quot;buzzle...&quot;
    }
  }
}

export Foo
export getBar
</code></pre>
<p>which exports the <code>type</code> with the same name and the <code>getBar</code> method while leaving the <code>bazzle</code> method as effectively private.</p>
<p>Constructors complicate this a bit. They don't have an exact replica in the pure type + functions perspective, because there is also special syntactic sugar for using them.</p>
<p>For instance, this class:</p>
<pre><code>class Foo {
  bar: string
  baz: bool

  constructor(bar: string, baz: bool) {
    this.bar = bar
    this.baz = baz
  }

  getBar(): string {
    return this.bar
  }

  bazzle(): string {
    if (this.baz) {
      return &quot;bazzle!&quot;
    } else {
      return &quot;buzzle...&quot;
    }
  }
}
</code></pre>
<p>could be functionally replicated by:</p>
<pre><code>type Foo {
  bar: string
  baz: bool
}

fn createFoo(bar: string, baz: bool): Foo {
  let this: Foo
  this.bar = bar
  this.baz = baz
  return this
}

fn getBar(this: Foo): string {
  return this.bar
}

fn bazzle(this: Foo): string {
  if (this.baz) {
    return &quot;bazzle!&quot;
  } else {
    return &quot;buzzle...&quot;
  }
}
</code></pre>
<p>But the calling of that constructor function would look like this for classes (examples assuming type inference is built):</p>
<pre><code>const foo = new Foo(&quot;bar&quot;, true)
</code></pre>
<p>and this way for types:</p>
<pre><code>const foo = createFoo(&quot;bar&quot;, true)
</code></pre>
<p>Essentially the same, but with the latter, I have to make sure I import <code>createFoo</code> while the former I get it for free and have this special functional syntax for new type creation that I don't get with pure types. I would like to figure out a way to solve that for both types and classes, but I haven't figured one out yet.</p>
<p>Both would still be able to create an instance using the type constant mechanism:</p>
<pre><code>const foo = new Foo {
  bar: &quot;bar&quot;
  baz: true
}
</code></pre>
<p>but that's not powerful enough when there are certain properties it is not expected that the user of the type would ever initialize, or if there are any particular side-effects necessary during initialization.</p>
<h3><a class="header" href="#modules" id="modules">Modules</a></h3>
<p>Modules in <code>alan</code> have already been discussed above with respect to <a href="modules.html#File-structure">their structure</a>  and <a href="modules.html#Imports">their resolution</a>. Some of this will be reviewed here, but the focus will be on management of modules within a project and some useful mechanisms the module resolution system provides.</p>
<h4><a class="header" href="#definition" id="definition">Definition</a></h4>
<p>Modules are defined by simply creating an <code>alan</code> source file. The name of the module is simply the name of the file minus the extension, unless the file is named <code>index.ln</code> in which case the name of the module is it's parent directory for anything referencing it. (This allows a former <code>something.ln</code> module to become <code>something/index.ln</code> and have a companion <code>something/submodule.ln</code> if it grows too big but should still be thought of as a singular unit.)</p>
<h4><a class="header" href="#resolution" id="resolution">Resolution</a></h4>
<p>The module resolution algorithm is inspired by multiple languages, but primarily Node.js. The recursive module resolution system makes it much easier to upgrade dependencies even if some of your own dependencies still depend on an older version of them.</p>
<p>This sounds like a security issue, but in practice it's better than the flat dependency model, as security updates can be applied as rapidly as possible to most of the codebase and not cause pain in the process, while a flat dependency model requires lockstep upgrades, so you cannot upgrade dependencies until all have released a version using the updated dependency, holding you back and causing weird chicken-and-egg issues. And tooling has sprung up in the Node community to track the laggards on updating and to override their dependency versions ifnecessary.</p>
<p>However, one of the issues with a tree-based module resolution system is many duplicate dependencies. Dependency hoisting and keeping the hierarchy as flat as possible helps eliminate this, and the module installation system should keep this in mind. <code>alan</code> will come with such a system baked into the language.</p>
<p>The other major issue with reducing the friction on using third-party modules is that you use third-party modules a whole lot as its easy to do, now. Combine that with Node.js's intentionally small standard library and there are lots of tiny modules that implement basic functionality because it wasn't available and people wrote and released their own implementations and other people installed the first ones they found.</p>
<p>Even more, the module resolution system in Node.js is <em>nicer</em> for third-party modules than for source code in your own project! Third party dependencies can be referenced by a memorable name, while code in your project must be referenced by relative pathing to the module in question, which becomes complicated when you need to traverse up and down the path by different amounts for different locations within your project, and also makes refactoring tedious when it is not obvious by a <code>git grep</code> which files are using your module.</p>
<p><code>alan</code>'s module resolution system attempts to address these concerns by having separate directories for third-party dependencies you install and being able to uniformly name modules within your own codebase clearly.</p>
<p>While relative pathing is necessary for a module to reference its submodule and it is possible to traverse up the tree and back down, having <code>../</code> in your import path should be considered an anti-pattern in <code>alan</code>.</p>
<p>A project directory structure like this:</p>
<pre><code>ecommerceco/
├── dependencies/
│   └── alanco/
│       └── sqlclient/
│           ├── index.ln
│           ├── mariadb.ln
│           ├── mysql.db
│           ├── postgres.ln
│           └── sqlserver.ln
├── index.ln
└── modules/
    ├── logger.ln
    ├── models/
    │   ├── index.ln
    │   ├── products.ln
    │   ├── purchases.ln
    │   ├── suppliers.ln
    │   └── users.ln
    └── views/
        ├── cart.ln
        ├── home.ln
        ├── index.ln
        ├── product_details.ln
        └── purchase.ln
</code></pre>
<p>Allows the root <code>index.ln</code> file to reference the logger with just <code>import @logger</code> to get <code>./modules/logger.ln</code> and the models with just <code>import @models</code> while the <code>./modules/models/index.ln</code> file can get the SQL client by <code>import @alanco/sqlclient</code> that comes from <code>./dependencies/alanco/sqlclient/index.ln</code></p>
<p>Similarly, <code>./modules/views/index.ln</code> is referenced as just <code>@views</code> by the <code>./index.ln</code> file and can reference the models with just <code>@models</code> as the resolution logic pops up and then discovers it's location for you. Module names are clear and memorable regardless of the origin: third-party and your own code can be treated the same, so there is no perverse incentive to publish helper modules you only use within your own project.</p>
<h4><a class="header" href="#acquisition" id="acquisition">Acquisition</a></h4>
<p>Different languages have had differing dependency resolution mechanisms.</p>
<ul>
<li>C and C++ have ignored this altogether and the communities have not made much, if any, progress on changing that.</li>
<li>Java has similarly ignored it, but the Java community has created a few competing module management systems, but have apparently centralized on the Maven repository for module sources.</li>
<li>Python has a centralized module repository and installation mechanism in <code>pip</code> but multiple mechanisms for managing the actual project dependency management, though with VirtualEnv leading (but not commandingly so) the pack.</li>
<li>Ruby and Node have fully centralized module repositories, dependency management (though there is a split between NPM and Yarn, but Yarn intentionally mirrors NPM and focuses on speed), and dependency installation.</li>
<li>Go and the experimental Deno have taken different paths. Go originally ignored dependency management, as well, but is adopting one based on URLs to Git repositories. Deno goes one step further and uses HTTP/HTTPS URLs to raw source code, itself.</li>
</ul>
<p><code>alan</code> intends to take care of third-party module management from the get-go, but will intentionally not handle hosting of the modules. Sooner or later, Node.js' dependency on NPM, Inc to function will bite it <em>when</em> (not if) NPM dies. The use of <code>git</code> as the de facto source code storage system makes the most sense to me. It can be easily vendored locally unlike Deno's approach, which requires a convoluted caching mechanism, and it provides simple mechanisms for change management that are more difficult with Deno (how does one roll back a change once the cached version of the old code is gone and the HTTP server no longer serves it?).</p>
<p>So <code>alan</code> will expect and use <code>git</code> for its package management. It will use the portion of the git URL after the host to determine the location to store the dependency in the <code>dependencies</code> directory.</p>
<p>It will only work within an <code>alan init</code>ed directory, which is a git repository that contains a <code>.lnan.ln</code> file, which is a collection of exported constants to configure the package management for you (avoiding the whole JSON vs YAML problem by declaring a pox on both houses). <em>ALL</em> configuration will be exported for this to be valid, so there will be no hidden behavior like with gradle's syntax, but you can still use the language itself to do some of the work. -- I hope that doesn't come back to bite me.</p>
<p>There will be a particular exported property that is a list of git URL fragments to try if a dependency is declared with the <code>@dep</code> syntax instead of a fully qualified git URL, with the <code>init</code> command automatically filling in the value of <code>git+ssh://git@github.com:</code>, the idea being that the <code>@</code> is stripped and the rest is appended to that URL to identify the git repository.</p>
<p>Specifying the version of the code you want is done by specifying the tag or SHA you wish to use. If you can support multiple versions (particularly if you're writing a library instead of acting as an end user) you can also provide an array of tags/shas or a special Semver object defining the major.minor.patch ranges acceptable. (This will depend on getting compound types in the type system first)</p>
<p>The dependencies will be added to the <code>dependencies</code> directory, which will also be in the <code>.gitignore</code> list created by <code>alan init</code>. These dependencies, once loaded, will check their own needed dependencies. If there is a dependency &quot;above&quot; them that contains a <code>git</code> repo with a valid tag, it's done. If it finds a <code>git</code> repo with an invalid tag, it will install its needed version locally in its own <code>dependencies</code> sub-directory. If it finds no match at all in the parent hierarchy, it will place its dependency in the <code>dependencies</code> directory it finds itself in to potentially reduce duplication of commonly-used third party dependencies.</p>
<p>At least that'll be the first pass -- lots of potential optimizations can be taken from &quot;yarn&quot;: determine if there are conflicting dependency needs across the entire tree and raise the most common version up while leaving the less common versions to be nested, instead of whichever was the first encountered. Also compute diffs of the dependency hierarchy before and after a dependency is added or removed and only perform the necessary operations instead of redoing everything.</p>
<h4><a class="header" href="#testing-and-mocking" id="testing-and-mocking">Testing and Mocking</a></h4>
<p>Testing is a very important part of any significant project. I believe the Perl community's culture of testing allowed the language to survive in mainstream usage longer than if it hadn't, as the rigorous testing many libraries had kept them manageable in the face of a language that didn't really care about that. Other languages adopted the techniques pioneered there, among them Java, which teaches another lesson.</p>
<p>Perl and other dynamic languages were able to make testing &quot;mocks&quot; of real code in order to better unit test the pieces separately that they behaved correctly in the face of uncommon results (like particular failure cases). But Java, being typed and static, had a very hard time tackling this issue, and reflection (and <a href="https://stackoverflow.com/a/2993641">sometimes direct byte-code manipulation!</a>) was necessary to get this working, warping the language and pushing for difficult-to-implement esoteric features.</p>
<p>Further, there are often third-party dependencies that are only useful when running your test suite but are not useful when running your code directly. For this reasons, test dependencies are placed in a <code>test/dependencies</code> subdirectory and all test code is expected to live in the <code>test</code> directory. If you wish to mock code from the primary path, simply define a mock in the <code>test/modules</code> directory to mock it for your entire test suite, or rename a particular test from <code>test/some_test.ln</code> to <code>test/some_test/index.ln</code> and place the test-specific mock into <code>test/some_test/modules/special_mock.ln</code> instead.</p>
<p>Simply from the dependency resolution system, isolated test dependencies and mocks are possible without reflection or run-time manipulation of the compiled code.</p>
<h4><a class="header" href="#mutation" id="mutation">Mutation</a></h4>
<p>Sometimes a third-party library or even a module you have written yourself needs to have its behavior adjusted, and simply defining new functions to use in method syntax is not enough to accomplish it. This can often be with respect to complex integration tests where you want to demonstrate the whole path works, but then &quot;plug up the ends&quot; and prevent actual mutations to escape your test suite.</p>
<p><code>alan</code> does not allow loops in the module dependency graph, it must be a directed acyclic graph, but it does have a special exception for a module attempting to import &quot;itself.&quot; In this case, the module will instead &quot;skip over&quot; itself and look across the rest of the <code>modules</code> and <code>dependencies</code> elsewhere in the graph for what it should pull in. This allows for defining a wrapper module that can export the same (or different) types, functions, etc but with different behavior, something in between a mock and the real thing (or something that intercepts a logger and also attaches stats tracing to it, as an example where this could be used in production).</p>
<p>This would work similarly in that only code that sees the <code>modules</code> directory containing this wrapper module would get the behavior, so to do an integration test using it, you need to wrap (or just symlink if left unchanged) all modules involved in the integration test. A bit more difficult, but doable.</p>
<h2><a class="header" href="#standard-library" id="standard-library">Standard Library</a></h2>
<p>The <code>alan</code> Standard Library is still a work in progress and barely complete enough to make non-trivial programs with, at the moment. The intention is to include many libraries such that &quot;normal&quot; usage of the language only requires libraries for access to third-party services, and then only as a convenience.</p>
<p><strong>Modules without an asterisk next to their name already exist. Modules with one asterisk should be built before any reachout to potential customers. Modules with two asterisks should be built before the OSS release. Modules with three asterisks should be built before the SaaS launch.</strong></p>
<h3><a class="header" href="#built-ins-included-without-import" id="built-ins-included-without-import">Built-ins (included without import)</a></h3>
<p>All module-based languages have some things that are included without specifically importing anything. Some keep it to a minimum (Java) and some have a pretty high rate of inclusion (Python). <code>alan</code> biases more towards the Python end of the spectrum. Concepts and functionality common across many modules should not be manually imported all of the time, especially with the requirement that imports are fully qualified to improve legibility.</p>
<p>The built-ins for <code>alan</code> all involve the built-in types and the functions and operators to manipulate them.</p>
<h4><a class="header" href="#built-in-types" id="built-in-types">Built-in Types</a></h4>
<p>The built-in types for <code>alan</code> are:</p>
<ul>
<li><code>void</code></li>
<li><code>int8</code></li>
<li><code>int16</code></li>
<li><code>int32</code></li>
<li><code>int64</code></li>
<li><code>float32</code></li>
<li><code>float64</code></li>
<li><code>bool</code></li>
<li><code>string</code></li>
<li><code>function</code></li>
<li><code>operator</code></li>
<li><code>Array&lt;V&gt;</code></li>
<li><code>Map&lt;K, V&gt;</code></li>
<li><code>KeyVal&lt;K, V&gt;</code></li>
<li><code>Tree&lt;V&gt;</code></li>
</ul>
<p>(At the time of writing, the Tree type is not functional)</p>
<p>There are no unsigned integers at this time due to the lack of such a primitive in Java. They will be added at some point in the future.</p>
<p>The <code>int64</code> and <code>float64</code> types are special among the numeric types, as these are the types that any numeric constant will be represented as, depending on whether or not it has a decimal.</p>
<h4><a class="header" href="#built-in-variable" id="built-in-variable">Built-in Variable</a></h4>
<p>There is <em>one</em> special built-in variable in the language, <code>_</code>. It is of type <code>void</code> and is used to throw away a value you don't want to save. This is only necessary if you have an operator-containing statement you wish to run but not pass to a function or anything else. This is a very esoteric need, since you could use the function form of one of the operators, but this can be desirable in certain situations.</p>
<h4><a class="header" href="#built-in-interfaces" id="built-in-interfaces">Built-in Interfaces</a></h4>
<p>There are a few built-in interfaces meant for working with several built-in types and functions.</p>
<ul>
<li><code>any</code> (an empty interface, it can match any value, but you can only accept it and pass it along to something else. Useful for logical &quot;glue&quot; functions like pair, cond, map, reduce, etc.)</li>
<li><code>Array&lt;any&gt;</code> (an array of some kind of value)</li>
<li><code>Stringifiable</code> (an interface with the single function definition of <code>fn toString(Stringifiable): string</code> to indicate that this type can be converted to a string)</li>
</ul>
<h4><a class="header" href="#built-in-functions" id="built-in-functions">Built-in Functions</a></h4>
<p>The function signatures will be written in the form <code>functionName(argumentType, argumentType): returnType</code> and then a brief description of each will be listed below it. These functions will be grouped into general categories, such as type coersion, arithmetic, etc.</p>
<h5><a class="header" href="#type-coersion" id="type-coersion">Type Coersion</a></h5>
<ul>
<li><code>toFloat64(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): float64</code>
Converts the provided value into a 64-bit floating point representation. <code>bool</code> becomes <code>1.0</code> or <code>0.0</code> while <code>string</code> is parsed as a floating point number.</li>
<li><code>toFloat64(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): float32</code>
Converts the provided value into a 32-bit floating point representation. <code>bool</code> becomes <code>1.0</code> or <code>0.0</code> while <code>string</code> is parsed as a floating point number.</li>
<li><code>toInt64(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): int64</code>
Converts the provided value into a 64-bit integer. <code>bool</code> becomes <code>1</code> or <code>0</code> while <code>string</code> is parsed as an integer</li>
<li><code>toInt32(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): int32</code>
Converts the provided value into a 32-bit integer. <code>bool</code> becomes <code>1</code> or <code>0</code> while <code>string</code> is parsed as an integer</li>
<li><code>toInt16(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): int16</code>
Converts the provided value into a 16-bit integer. <code>bool</code> becomes <code>1</code> or <code>0</code> while <code>string</code> is parsed as an integer</li>
<li><code>toInt8(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): int8</code>
Converts the provided value into an 8-bit integer. <code>bool</code> becomes <code>1</code> or <code>0</code> while <code>string</code> is parsed as an integer</li>
<li><code>toBool(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): bool</code>
Converts the provided value into a boolean. Numeric values becomes <code>true</code> if not <code>0</code> and <code>false</code> otherwise while <code>string</code> is parsed as a <code>bool</code></li>
<li><code>toString(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): string</code>
Converts the provided value into a string.</li>
</ul>
<h5><a class="header" href="#arithmetic" id="arithmetic">Arithmetic</a></h5>
<ul>
<li><code>add(int8, int8): int8</code>, <code>add(int16, int16): int16</code>, <code>add(int32, int32): int32</code>, <code>add(int64, int64): int64</code>, <code>add(float32, float32): float32</code>, <code>add(float64, float64): float64</code>
Adds two numbers together and returns the result. The numbers must be of the same type.</li>
<li><code>sub(int8, int8): int8</code>, <code>sub(int16, int16): int16</code>, <code>sub(int32, int32): int32</code>, <code>sub(int64, int64): int64</code>, <code>sub(float32, float32): float32</code>, <code>sub(float64, float64): float64</code>
Subtracts two numbers and returns the result. The numbers must be of the same type.</li>
<li><code>mul(int8, int8): int8</code>, <code>mul(int16, int16): int16</code>, <code>mul(int32, int32): int32</code>, <code>mul(int64, int64): int64</code>, <code>mul(float32, float32): float32</code>, <code>mul(float64, float64): float64</code>
Multiplies two numbers and returns the result. The numbers must be of the same type.</li>
<li><code>div(int8, int8): int8</code>, <code>div(int16, int16): int16</code>, <code>div(int32, int32): int32</code>, <code>div(int64, int64): int64</code>, <code>div(float32, float32): float32</code>, <code>div(float64, float64): float64</code>
Divides two numbers and returns the result. The numbers must be of the same type.</li>
<li><code>pow(int8, int8): int8</code>, <code>pow(int16, int16): int16</code>, <code>pow(int32, int32): int32</code>, <code>pow(int64, int64): int64</code>, <code>pow(float32, float32): float32</code>, <code>pow(float64, float64): float64</code>
Raises the first number to the power of the second number and returns the result. The numbers must be of the same type.</li>
<li><code>mod(int8, int8): int8</code>, <code>mod(int16, int16): int16</code>, <code>mod(int32, int32): int32</code>, <code>mod(int64, int64): int64</code>
Takes the modulus (returns the remainder of) the first number by the second number. Both numbers must be of the same type and this is the only arithmetic function that does not support floating point numbers.</li>
<li><code>sqrt(float32): float32</code>, <code>sqrt(float64): float64</code>
Returns the square root of the provided value. Equivalent to <code>pow(yourNumber, 0.5)</code> but common enough in calculations to be defined separately.</li>
</ul>
<h5><a class="header" href="#logical-and-bitwise" id="logical-and-bitwise">Logical and Bitwise</a></h5>
<ul>
<li><code>and(int8, int8): int8</code>, <code>and(int16, int16): int16</code>, <code>and(int32, int32): int32</code>, <code>and(int64, int64): int64</code>, <code>and(bool, bool): bool</code>
Applies the <code>and</code> truth table to the inputs. If integers, it applies bitwise, if boolean, to the single bit.</li>
<li><code>or(int8, int8): int8</code>, <code>or(int16, int16): int16</code>, <code>or(int32, int32): int32</code>, <code>or(int64, int64): int64</code>, <code>or(bool, bool): bool</code>
Applies the <code>or</code> truth table to the inputs. If integers, it applies bitwise, if boolean, to the single bit.</li>
<li><code>xor(int8, int8): int8</code>, <code>xor(int16, int16): int16</code>, <code>xor(int32, int32): int32</code>, <code>xor(int64, int64): int64</code>, <code>xor(bool, bool): bool</code>
Applies the <code>xor</code> truth table to the inputs. If integers, it applies bitwise, if boolean, to the single bit.</li>
<li><code>not(int8): int8</code>, <code>not(int16): int16</code>, <code>not(int32): int32</code>, <code>not(int64): int64</code>, <code>not(bool): bool</code>
Applies the <code>not</code> truth table to the input. If integers, it applies bitwise, if boolean, to the single bit.</li>
<li><code>nand(int8, int8): int8</code>, <code>nand(int16, int16): int16</code>, <code>nand(int32, int32): int32</code>, <code>nand(int64, int64): int64</code>, <code>nand(bool, bool): bool</code>
Applies the <code>nand</code> truth table to the inputs. If integers, it applies bitwise, if boolean, to the single bit.</li>
<li><code>nor(int8, int8): int8</code>, <code>nor(int16, int16): int16</code>, <code>nor(int32, int32): int32</code>, <code>nor(int64, int64): int64</code>, <code>nor(bool, bool): bool</code>
Applies the <code>nor</code> truth table to the inputs. If integers, it applies bitwise, if boolean, to the single bit.</li>
<li><code>xnor(int8, int8): int8</code>, <code>xnor(int16, int16): int16</code>, <code>xnor(int32, int32): int32</code>, <code>xnor(int64, int64): int64</code>, <code>xnor(bool, bool): bool</code>
Applies the <code>xnor</code> truth table to the inputs. If integers, it applies bitwise, if boolean, to the single bit.</li>
</ul>
<h5><a class="header" href="#comparators" id="comparators">Comparators</a></h5>
<ul>
<li><code>eq(int8, int8): bool</code>, <code>eq(int16, int16): bool</code>, <code>eq(int32, int32): bool</code>, <code>eq(int64, int64): bool</code>, <code>eq(float32, float32): bool</code>, <code>eq(string, string): bool</code>, <code>eq(bool, bool): bool</code>
Determines if the two values are equal.</li>
<li><code>neq(int8, int8): bool</code>, <code>neq(int16, int16): bool</code>, <code>neq(int32, int32): bool</code>, <code>neq(int64, int64): bool</code>, <code>neq(float32, float32): bool</code>, <code>neq(string, string): bool</code>, <code>neq(bool, bool): bool</code>
Determines if the two values are not equal.</li>
<li><code>lt(int8, int8): bool</code>, <code>lt(int16, int16): bool</code>, <code>lt(int32, int32): bool</code>, <code>lt(int64, int64): bool</code>, <code>lt(float32, float32): bool</code>, <code>lt(string, string): bool</code>
Determines if the first value is less than the second (for strings, the first character that is less than the other determines this)</li>
<li><code>lte(int8, int8): bool</code>, <code>lte(int16, int16): bool</code>, <code>lte(int32, int32): bool</code>, <code>lte(int64, int64): bool</code>, <code>lte(float32, float32): bool</code>, <code>lte(string, string): bool</code>
Determines if the first value is less than or equal to the second (for strings, the first character that is less than the other determines this)</li>
<li><code>gt(int8, int8): bool</code>, <code>gt(int16, int16): bool</code>, <code>gt(int32, int32): bool</code>, <code>gt(int64, int64): bool</code>, <code>gt(float32, float32): bool</code>, <code>gt(string, string): bool</code>
Determines if the first value is greater than the second (for strings, the first character that is greater ehan the other determines this)</li>
<li><code>gte(int8, int8): bool</code>, <code>gte(int16, int16): bool</code>, <code>gte(int32, int32): bool</code>, <code>gte(int64, int64): bool</code>, <code>gte(float32, float32): bool</code>, <code>gte(string, string): bool</code>
Determines if the first value is greater than or equal to the second (for strings, the first character that is greater ehan the other determines this)</li>
</ul>
<h5><a class="header" href="#string-manipulation" id="string-manipulation">String Manipulation</a></h5>
<p>The regular-expression-based string manipulation functions may not make it into the language. Modern regex engines are (painfully) turing complete and difficult to estimate the run-time of even when not abused. I'm still thinking about this one, but likely they're out.</p>
<ul>
<li><code>concat(...string): string</code>
Accepts one or more strings and concatenates them together.</li>
<li><code>repeat(string, int8 | int16 | int32 | int64): string</code>
Takes a string and concatenates it to an empty string as many times as specified (so <code>repeat(&quot;hello&quot;, 1)</code> returns <code>&quot;hello&quot;</code>, not <code>&quot;hellohello&quot;</code>)</li>
<li><code>matches(string, string): bool</code>
Determines if the first string contains the regex pattern defined in the second string.</li>
<li><code>index(string, string): int64</code>
Finds where in the first string the substring defined by the second string is located. Returns the first match if multiple exist.</li>
<li><code>length(string): int64</code>
Returns the number of characters in the string.</li>
<li><code>trim(string): string</code>
Removes whitespace from the beginning and end of the string.</li>
<li><code>split(string, string): Array&lt;string&gt;</code>
Returns an array of substrings split by the second string (but not including said second string in the results).</li>
<li><code>template(string, map&lt;string, string&gt;): string</code>
Returns a string substituting in values for specific key substrings in the map. Template syntax is simply putting <code>${keyname}</code> anywhere you want the value of that key substituted.</li>
</ul>
<p>To be added Soon (tm) (or not, see above):</p>
<ul>
<li><code>find(string, string): FindObj</code>
Finds all locations within a string where the second regex string matches and returns a special object with the original string, match locations, and match substrings extracted.</li>
<li><code>replace(string, string, string): string</code>, <code>replace(FindObj, string): string</code>
Using the results of a prior find, or doing it in-place, takes all matches from a regex search and replaces with the specified text. (How much of PCRE to include here? Should back references be allowed? Could be an escape to turing completeness in a weird way.)</li>
</ul>
<h5><a class="header" href="#ternary-functions" id="ternary-functions">&quot;Ternary&quot; Functions</a></h5>
<p>The &quot;ternary&quot; operator (<code>booleanVal ? trueval : falseval</code>) is implemented in <code>alan</code> (and in many languages) as two infix operators, <code>?</code> and <code>:</code>. These operators are powered by the <code>cond</code> and <code>pair</code> functions, respectively.</p>
<ul>
<li><code>pair(any, any): Array&lt;any&gt;</code>
Takes two values and returns an array of these two values</li>
<li><code>cond(bool, Array&lt;any&gt;): any</code>
Takes a boolean conditional and an array of two values and returns either the first or second value</li>
</ul>
<h5><a class="header" href="#map-manipulation" id="map-manipulation">Map Manipulation</a></h5>
<p><code>Map</code>s are generally used just for assignment and lookup of data, but there are occasions where you need to operate on the entirety of the <code>Map</code> without any particular key in mind.</p>
<ul>
<li><code>keyVal(Map&lt;any, any&gt;): Array&lt;KeyVal&lt;any, any&gt;&gt;</code>
Takes the Map of key-value pairs and returns an array of <code>KeyVal</code> value types with <code>key</code> and <code>value</code> fields.</li>
<li><code>keys(Map&lt;any, any&gt;): Array&lt;any&gt;</code>
Returns an array of keys for the <code>Map</code></li>
<li><code>values(Map&lt;any, any&gt;): Array&lt;any&gt;</code>
Returns an array of the values for the <code>Map</code></li>
<li><code>length(Map&lt;any, any&gt;): int64</code>
Returns the number of key-value pairs in the <code>Map</code></li>
</ul>
<h5><a class="header" href="#array-manipulation" id="array-manipulation">Array Manipulation</a></h5>
<p><code>Array</code>s are the backbone of this language. Any kind of repetitive work is expressed through <code>Array</code>s and the creation and manipulation thereof. Several of the <code>string</code> manipulation functions have an <code>Array</code> equivalent, and then there are a whole class of tools, mostly from functional programming, specific to them.</p>
<p>Starting with the functions that also work on <code>string</code>s:</p>
<ul>
<li><code>concat(...Array&lt;any&gt;): Array&lt;any&gt;</code>
Accepts one or more arrays and creates a new array with the fields shallowly copied.</li>
<li><code>repeat(Array&lt;any&gt;, int8 | int16 | int32 | int64): Array&lt;any&gt;</code>
Creates a new shallow-copied array with the contents of the new Array repeating the original array the specified number of times.</li>
<li><code>index(Array&lt;any&gt;, any&gt;): int64</code>
This function looks for the first value in the array equal to the provided value and returns that index, or <code>-1</code>.</li>
<li><code>length(Array&lt;any&gt;): int64</code>
Returns the number of elements in the Array.</li>
</ul>
<p>A special function just for <code>Array</code>s and <code>string</code>s:</p>
<ul>
<li><code>join(Array&lt;string&gt;, string): string</code>
This function takes the elements of the array, which are all strings, and concatenates them together with the second argument, a separator string, in between them, and then returns the resulting string.</li>
</ul>
<p>The functional programming-inspired <code>Array</code> functions:</p>
<ul>
<li><code>each(Array&lt;any&gt;, fn (any): void): void</code>
This function calls a side-effect function for each element of the array.</li>
<li><code>map(Array&lt;any&gt;, fn (any): any): Array&lt;any&gt;</code>
This function allows an array to be transformed into another array with a different set of data after being given a transform function. Coming Soon (tm) more advanced interfaces will provide more solid guarantees that the return type of the transform function matches the return type of the map call itself (needed for the compiler, the interpreter works without it because values are stored dynamically).</li>
<li><code>reduce(Array&lt;any&gt;, fn (any, any): any): any</code>
This function takes an array and an function that takes two arguments (so equivalent to an infix operator) and merges all of the values together until a single output is provided.</li>
<li><code>filter(Array&lt;any&gt;, fn (any): bool): Array&lt;any&gt;</code>
This function takes an array and a filter function that specifies which elements should be kept (<code>true</code>) and which should be skipped (<code>false</code>).</li>
<li><code>find(Array&lt;any&gt;, fn(any): bool): any</code>
This function takes an array and a fitler function and returns the first value that passes the test of the filter function.</li>
<li><code>every(Array&lt;any&gt;, fn(any): bool): bool</code>
This function takes an array and a filter function and indicates if every field in the array passed the test (<code>true</code>) or not (<code>false</code>)</li>
<li><code>some(Array&lt;any&gt;, fn(any): bool): bool</code>
This function takes an array and a filter function and indicates if any field in the array passed the test or not.</li>
</ul>
<h4><a class="header" href="#built-in-operators" id="built-in-operators">Built-in Operators</a></h4>
<p>The built-in operators in <code>alan</code> are all simply aliases for most of the functions listed above. The following table defines the mapping from operator to function:</p>
<p>Operator Infix/Prefix Precedence Commutative Associative Function(s)</p>
<hr />
<p><code>+</code>        Infix         2         Yes, No      Yes     add, concat
<code>-</code>        Infix         2         No           No         sub
<code>*</code>        Infix         3         Yes, No    Yes, No   mul, repeat
<code>/</code>        Infix         3         No           No         div
<code>**</code>       Infix         4         No           No         pow
<code>%</code>        Infix         3         No           No         mod
<code>&amp;</code>        Infix         3         Yes          Yes        and
<code>&amp;&amp;</code>       Infix         3         Yes          Yes        and
<code>|</code>        Infix         2         Yes          Yes        or
<code>||</code>       Infix         2         Yes          Yes        or
<code>^</code>        Infix         2         Yes          Yes        xor
<code>!</code>        Prefix        4         N/A          N/A        not
<code>!&amp;</code>       Infix         3         Yes          Yes        nand
<code>!|</code>       Infix         2         Yes          Yes        nor
<code>!^</code>       Infix         2         Yes          Yes        xnor
<code>==</code>       Infix         1         Yes          Yes        eq
<code>!=</code>       Infix         1         Yes          Yes        neq
<code>&lt;</code>        Infix         1         No           Yes        lt
<code>&lt;=</code>       Infix         1         No           Yes        lte
<code>&gt;</code>        Infix         1         No           Yes        gt
<code>&gt;=</code>       Infix         1         No           Yes        gte
<code>~</code>        Infix         1         No           No         matches
<code>@</code>        Infix         1         No           No         index
<code>#</code>        Prefix        4         N/A          N/A        length
<code>`</code>    Prefix        4         N/A          N/A        trim
<code>?</code>        Infix         0         No           No         cond
<code>:</code>        Infix         5         No           No         pair</p>
<p>Table: Built-in Operator Mapping Table</p>
<h3><a class="header" href="#stdapp" id="stdapp">@std/app*</a></h3>
<p>Currently very bare, only a single <code>print</code> function that takes all of the basic types and puts it on the console, and two events <code>start</code> and <code>exit</code>, with <code>start</code> intended to be handled by the user as it is automatically emitted <em>once</em> by the interpreter and <code>exit</code> to be emitted by the user when the program should finish and is automatically handled by the interpreter to terminate the application.</p>
<p>The formal declarations:</p>
<p><code>fn print(int8 | int16 | int32 | int64 | float32 | float64 | bool | string): void</code></p>
<p><code>event start: void</code></p>
<p><code>event exit: int8</code></p>
<p>Eventually things like printing to <code>stderr</code> will be added, being able to print without an automatic newline attached, reading from <code>stdin</code> after I figure out how I want to expose that at all (since it has a non-deterministic time, I'm currently thinking it'll be an event you can listen to), and getting the <code>argv</code> array and <code>env</code> variables it was executed with in POSIX-like environments.</p>
<p>Almost <em>all</em> of these will be non-functional in the SaaS product, though (or perhaps should have mocks involved?) so I would prefer if most third-party libraries ignored them.</p>
<h4><a class="header" href="#proposed-changes" id="proposed-changes">Proposed changes</a></h4>
<p>Instead of making these non-functional in the SaaS product, they should just behave differently. <code>start</code> is only run once per cluster deploy, <code>exit</code> terminates the entire cluster. <code>print</code> will be reimplemented on top of events, as well.</p>
<p>New features:</p>
<p><code>event stdout: string</code></p>
<p><code>event stderr: string</code></p>
<p><code>event stdin: string</code></p>
<p>Process stdout/err/in are event sources (or sinks). In the OSS runtime they behave as expected, in the SaaS cluster they're used for logging to a dashbaord (and maybe even allowing a side-channel input in the same dashboard via <code>stdin</code>?)</p>
<p><code>print</code> in this case becomes something like:</p>
<pre><code>interface Stringifiable {
  toString(Stringifiable): string
}

fn print(val: Stringifiable) {
  emit stdout val + &quot;\n&quot;
}
</code></pre>
<p>Other metadata about the application in general ought to be accessed here. I don't have a full idea of what should be here, but getting stats on CPU usage, memory usage, file descriptors, event loop queue depth, etc.</p>
<h3><a class="header" href="#stdtrig" id="stdtrig">@std/trig</a></h3>
<p>In <code>alan</code> the different fields of math are given their own respective libraries, both to encourage more complete support of each field and to keep them clearly labeled and segmented from each other to reduce noise pollution from differing terminologies amongsth them. Trigonometric functions and constants are housed in this standard library.</p>
<p>There are three numeric constants defined: <code>e</code>, <code>tau</code>, and <code>pi</code>.</p>
<p><code>e</code> is Euler's Number approximately <code>2.72</code> and was discovered <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">while analyzing compound interest</a>.</p>
<p><code>tau</code> is the number of radians to complete a full circle, approximately <code>6.28</code> while <code>pi</code> is half that at approximately <code>3.14</code>. For historical reasons <code>pi</code> is used and cited more often, though <code>tau</code> simplifies certain equation forms and the direct ratio between it and percentages on a Pie Chart (eg <code>25%</code> on a Pie Chart is equal to <code>tau / 4</code>) make it the clearer instructional tool.</p>
<p>The functions provided by <code>@std/trig</code> fall into the following categories: Logarithms &amp; Exponents, Basic Trigonometric Functions, Inverse Trigonometric Functions, Historical Trigonometric Functions, Inverse Historical Trigonometric Functions, Hyperbolic Trigonometric Functions, and Inverse Hyperbolic Trigonometric Functions. <a href="https://en.wikipedia.org/wiki/Trigonometric_functions">Wikipedia has lots of great material on them all</a>.</p>
<h4><a class="header" href="#logarithms--exponents" id="logarithms--exponents">Logarithms &amp; Exponents</a></h4>
<ul>
<li><code>exp(float32): float32</code>, <code>exp(float64): float64</code>
This function returns the value of <code>e^x</code> and is equivalent to <code>pow(trig.e, x)</code> but is commonly written this way in trigonometric functions in physics, electrical engineering, etc.</li>
<li><code>ln(float32): float32</code>, <code>ln(float64): float64</code>
This function returns the natural log (log base-e) of the provided value.</li>
<li><code>log(float32): float32</code>, <code>log(float64): float64</code>
This function returns log base-10 of the provided value.</li>
</ul>
<h4><a class="header" href="#basic-trigonometric-functions" id="basic-trigonometric-functions">Basic Trigonometric Functions</a></h4>
<ul>
<li><code>sin(float32): float32</code>, <code>sin(float64): float64</code>
Returns the ratio of the opposite side versus the hypotenuse (sine) for the given angle in radians.</li>
<li><code>cos(float32): float32</code>, <code>cos(float64): float64</code>
Returns the ratio of the adjacent side versus the hypotenuse (cosine) for the given angle in radians.</li>
<li><code>tan(float32): float32</code>, <code>tan(float64): float64</code>
Returns the ratio of the opposite side versus the adjacent side (tangent) for the given angle in radians.</li>
<li><code>sec(float32): float32</code>, <code>sec(float64): float64</code>
Returns the ratio of the hypotenuse versus the adjacent side (secant) for the given angle in radians.</li>
<li><code>csc(float32): float32</code>, <code>csc(float64): float64</code>
Returns the ratio of the hypotenuse versus the opposite side (cosecant) for the given angle in radians.</li>
<li><code>cot(float32): float32</code>, <code>cot(float64): float64</code>
Returns the ratio of the adjacent side versus the opposite side (cotangent) for the given angle in radians.</li>
</ul>
<h4><a class="header" href="#inverse-trigonometric-functions" id="inverse-trigonometric-functions">Inverse Trigonometric Functions</a></h4>
<ul>
<li><code>arcsin(float32): float32</code>, <code>arcsin(float64): float64</code>
Returns the angle in radians for the given ratio of the opposite side versus the hypotenuse (arcsine).</li>
<li><code>arccos(float32): float32</code>, <code>arccos(float64): float64</code>
Returns the angle in radians for the given ratio of the adjacent side versus the hypotenuse (arccosine).</li>
<li><code>arctan(float32): float32</code>, <code>arctan(float64): float64</code>
Returns the angle in radians for the given ratio of the opposite side versus the adjacent side (arctangent).</li>
<li><code>arcsec(float32): float32</code>, <code>arcsec(float64): float64</code>
Returns the angle in radians for the given ratio of the hypotenuse versus the adjacent side (arcsecant).</li>
<li><code>arccsc(float32): float32</code>, <code>arccsc(float64): float64</code>
Returns the angle in radians for the given ratio of the hypotenuse versus the opposite side (arccosecant).</li>
<li><code>arccot(float32): float32</code>, <code>arccot(float64): float64</code>
Returns the angle in radians for the given ratio of the adjacent side versus the opposite side (arccotangent).</li>
</ul>
<h4><a class="header" href="#historical-trigonometric-functions" id="historical-trigonometric-functions">Historical Trigonometric Functions</a></h4>
<p>Historically, common forms of the combinations and/or formula fragments using the above trigonometric functions would be precomputed and kept in look-up books as fast computational processes were not available. (To be fair, you don't even need all of the above to define everything, you could redefine everything based on just <code>sin</code> and <code>arcsin</code>) These forms were often used in computing distances across the globe, for instance, but also <a href="https://en.wikipedia.org/wiki/File:Circle-trig6.svg">&quot;fill in the blanks&quot; of many line segments that can be traced out by the basic trigonometric functions</a> making them very useful as a teaching aid in trigonometry, as well.</p>
<p>So, because I can, I included EVERY LAST ONE OF THEM.</p>
<ul>
<li><code>ver(float32): float32</code>, <code>ver(float64): float64</code>
The <code>versine</code> returns the inverse of a <code>cosine</code> and shifted up such that the range is from 0 to 2, and is equivalent to the portion of the unit circle radius along the ray of the adjacent side that is not covered by that side.</li>
<li><code>vcs(float32): float32</code>, <code>vcs(float64): float64</code>
The <code>vercosine</code> returns a <code>cosine</code> shifted up such that the range is from 0 to 2.</li>
<li><code>cvs(float32): float32</code>, <code>cvs(float64): float64</code>
The <code>coversine</code> returns the inverse of a <code>sine</code> shifted up such that the range is from 0 to 2.</li>
<li><code>cvc(float32): float32</code>, <code>cvc(float64): float64</code>
The <code>covercosine</code> returns a <code>sine</code> shifted up such that the range is from 0 to 2.</li>
<li><code>hav(float32): float32</code>, <code>hav(float64): float64</code>
The <code>haversine</code> is half a <code>versine</code>, such that it is an inverted half <code>cosine</code> shifted up such that the range is from 0 to 1. It is an important component in calculating great circle distances on a sphere. It was once used for navigation across the world and still does a decent job at shorter distances but has been overtaken by more precise models of the world.</li>
<li><code>hvc(float32): float32</code>, <code>hvc(float64): float64</code>
The <code>havercosine</code> is half a <code>vercosine</code>, it is a half <code>cosine</code> that has been shifted up such that the range is from 0 to 1.</li>
<li><code>hcv(float32): float32</code>, <code>hcv(float64): float64</code>
The <code>hacoversine</code> is an inverted half <code>sine</code> that has been shifted up such that the range is from 0 to 1.</li>
<li><code>hcc(float32): float32</code>, <code>hcc(float64): float64</code>
The <code>hacovercosine</code> is a half <code>sine</code> that has been shifted up such that the range is from 0 to 1.</li>
<li><code>exs(float32): float32</code>, <code>exs(float64): float64</code>
The <code>exsecant</code> is the <code>secant</code> minus the unit circle radius of <code>1</code>, and is the portion of the secant that falls outside of the unit circle.</li>
<li><code>exc(float32): float32</code>, <code>exc(float64): float64</code>
The <code>excosecant</code> is the <code>cosecant</code> minus the unit circle radius of <code>1</code>, and is the portion of the cosecant that falls outside of the unit circle.</li>
<li><code>crd(float32): float32</code>, <code>crd(float64): float64</code>
The <code>chord</code> is the straight-line segment connecting the points where the unit circle rays from the hypotenuse and adjacent sides come from, forming a triangle where two sides have a length of <code>1</code> and the other the length of the <code>chord</code> and is equal to <code>2</code> times the <code>sine</code> of half the original angle <code>theta</code>.</li>
</ul>
<h4><a class="header" href="#inverse-historical-trigonometric-functions" id="inverse-historical-trigonometric-functions">Inverse Historical Trigonometric Functions</a></h4>
<ul>
<li><code>arcver(float32): float32</code>, <code>arcver(float64): float64</code>
The <code>arcversine</code> reverses the <code>versine</code> function and returns the original angle defining it.</li>
<li><code>arcvcs(float32): float32</code>, <code>arcvcs(float64): float64</code></li>
<li><code>arccvs(float32): float32</code>, <code>arccvs(float64): float64</code></li>
<li><code>arccvc(float32): float32</code>, <code>arccvc(float64): float64</code></li>
<li><code>archav(float32): float32</code>, <code>archav(float64): float64</code></li>
<li><code>archvc(float32): float32</code>, <code>archvc(float64): float64</code></li>
<li><code>archcv(float32): float32</code>, <code>archcv(float64): float64</code></li>
<li><code>archcc(float32): float32</code>, <code>archcc(float64): float64</code></li>
<li><code>arcexs(float32): float32</code>, <code>arcexs(float64): float64</code></li>
<li><code>arcexc(float32): float32</code>, <code>arcexc(float64): float64</code></li>
<li><code>arccrd(float32): float32</code>, <code>arccrd(float64): float64</code></li>
</ul>
<h4><a class="header" href="#hyperbolic-trigonometric-functions" id="hyperbolic-trigonometric-functions">Hyperbolic Trigonometric Functions</a></h4>
<ul>
<li><code>sinh(float32): float32</code>, <code>sinh(float64): float64</code>
Returns the y-axis value of the intersection point of the unit hyperbola with a ray starting at (0, 0) such that the area defined versus the x-axis is half the provided value (<a href="https://en.wikipedia.org/wiki/File:Hyperbolic_functions-2.svg">See this diagram</a> for more clarity).</li>
<li><code>cosh(float32): float32</code>, <code>cosh(float64): float64</code>
Returns the x-axis value of the intersection point of the unit hyperbola with a ray starting at (0, 0) such that the area defined versus the x-axis is half the provided value.</li>
<li><code>tanh(float32): float32</code>, <code>tanh(float64): float64</code>
Returns the ratio between the hyperbolic sine and cosine, bounded from <code>-1</code> to <code>1</code>.</li>
<li><code>sech(float32): float32</code>, <code>sech(float64): float64</code>
Returns the one over the hyperbolic cosine.</li>
<li><code>csc(float32): float32</code>, <code>csc(float64): float64</code>
Returns the one over the hyperbolic sine.</li>
<li><code>cot(float32): float32</code>, <code>cot(float64): float64</code>
Returns the one over the hyperbolic tangent.</li>
</ul>
<h4><a class="header" href="#inverse-hyperbolic-trigonometric-functions" id="inverse-hyperbolic-trigonometric-functions">Inverse Hyperbolic Trigonometric Functions</a></h4>
<ul>
<li><code>arcsinh(float32): float32</code>, <code>arcsinh(float64): float64</code>
Reverses the hyperbolic sine.</li>
<li><code>arccosh(float32): float32</code>, <code>arccosh(float64): float64</code></li>
<li><code>arctanh(float32): float32</code>, <code>arctanh(float64): float64</code></li>
<li><code>arcsech(float32): float32</code>, <code>arcsech(float64): float64</code></li>
<li><code>arccsch(float32): float32</code>, <code>arccsch(float64): float64</code></li>
<li><code>arccoth(float32): float32</code>, <code>arccoth(float64): float64</code></li>
</ul>
<h3><a class="header" href="#stdstats" id="stdstats">@std/stats*</a></h3>
<p>Not yet built, but statistical functions, including random number generators and timing/sampling functionality would live here along with <code>mean</code>, <code>median</code>, <code>mode</code>, <code>stddev</code>, <code>round</code>, etc.</p>
<p><code>round</code> could have multiple forms, like <code>round(float32): int32</code> that rounds to the nearest integer while <code>round(float32, float32): float32</code> could round to the nearest step size defined in the second argument, eg <code>round(3.14, 0.1) == 3.1</code> and <code>round(123, 5) == 125</code>.</p>
<h3><a class="header" href="#stdhttp" id="stdhttp">@std/http*</a></h3>
<p>A Node or Express-like http client will live here, probably. Going to look at several HTTP client and server libraries but will consider Java's (and Apache's) implementations anti-patterns to avoid, even though I initially have to build my API on top of that.</p>
<p>For now, the <code>http</code> library has three types: <code>Server</code>, <code>Request</code>, and <code>Response</code>, and two functions, <code>server</code>, and <code>listen</code>.</p>
<h4><a class="header" href="#http-types" id="http-types">HTTP Types</a></h4>
<pre><code>type Server {
  handler: fn (Request): Response
  port: int16
}
</code></pre>
<pre><code>type Request {
  method: string
  uri: string
  path: string
  headers: Map&lt;string, string&gt;
  body: string
}
</code></pre>
<pre><code>type Response {
  statusCode: int16
  headers: Map&lt;string, string&gt;
  body: string
}
</code></pre>
<h4><a class="header" href="#http-functions" id="http-functions">HTTP Functions</a></h4>
<ul>
<li><code>server(fn (Request): Response): Server</code>
Creates an HTTP server with the specified handler</li>
<li>`listen(Server, int8 | int16 | int32 | int64): Server
Sets the port for the server and implicitly starts it.</li>
</ul>
<h4><a class="header" href="#re-proposed-http-library" id="re-proposed-http-library">Re-proposed http library</a></h4>
<p>Instead of sticking so close to the Express style, getting this hooked into the event loop can produce a potentially more idiomatic API, but it requires a tweak to how events work:</p>
<pre><code>import @std/http

on http.port(80) fn (socket: http.Socket) {
  socket.response.body = &quot;Hello, World!&quot;
  http.close(socket)
}
</code></pre>
<p>Event handlers must still be declared in module scope, but <code>Event</code> values can be created by functions and used for handler registration and emits.</p>
<p>There must also be an http request library. Here is a proposed view of how it should look to the end user:</p>
<pre><code>import @std/app
import @std/http

on app.start {
  const resp = http.fetch(new http.Request {
    method = &quot;GET&quot;
    uri = &quot;https://google.com&quot;
  })
  app.print(resp.body)
  emit exit 0
}
</code></pre>
<h3><a class="header" href="#stddht" id="stddht">@std/dht*</a></h3>
<p>Just the distributed hash table piece that can be used as the primitive for the underlying distributed database work.</p>
<pre><code>type DHT&lt;Val&gt; {
  // special hidden behavior
}
</code></pre>
<p><code>fn has(string): bool</code></p>
<p><code>fn set(string, Val)</code></p>
<p><code>fn get(string): Val</code></p>
<p><code>fn delete(string)</code></p>
<p><code>fn getAndSet(string, fn (Val): Val)</code></p>
<p>I believe these 5 functions are the primitives needed for this, but it may change once theory hits reality.</p>
<h3><a class="header" href="#stddatastore" id="stddatastore">@std/datastore*</a></h3>
<p>I'm open to a better name for this.</p>
<p>This is the part that implements a SQL-like database layer on top of the <code>DHT</code> type. I'm not sure if it should automatically include.</p>
<h3><a class="header" href="#stdlogger" id="stdlogger">@std/logger*</a></h3>
<p>Why <code>logger</code> when you already have <code>print</code>? For proper warning levels and so on. Each of the logger functions are wrappers around constructing a <code>Log</code> struct, a <code>log</code> event, and there is also a built-in <code>toString</code> function for it as well, so you can configure it to go to <code>stdout</code> with a simple:</p>
<pre><code>on log print
</code></pre>
<p>Or not include that and instead have something else handle the logs for you (like going to LogDNA, Datadog, etc). List of potential events, types, and functions:</p>
<pre><code>type Log {
  level: string // or an enum type? or an integer?
  message: string
  metadata: Map&lt;string, Stringifiable&gt; // took this from the Node loggers, not sure if desirable
}
</code></pre>
<p><code>event log Log</code></p>
<p><code>fn toString(Log): string</code></p>
<p><code>fn debug(string, Map&lt;string, Stringifiable&gt;)</code> and <code>fn debug(string)</code></p>
<p><code>fn log(string, Map&lt;string, Stringifiable&gt;)</code> and <code>fn log(string)</code></p>
<p><code>fn warn(string, Map&lt;string, Stringifiable&gt;)</code> and <code>fn warn(string)</code></p>
<p><code>fn error(string, Map&lt;string, Stringifiable&gt;)</code> and <code>fn error(string)</code></p>
<p><code>fn fatal(string, Map&lt;string, Stringifiable&gt;)</code> and <code>fn fatal(string)</code></p>
<p>The <code>toString</code> function simply converts the <code>Log</code> entry into a string. </p>
<p>The logger functions automatically set the appropriate <code>level</code>, then set the message string and optionally metadata for the log. The <code>fatal</code> function also emits an <code>exit</code> event.</p>
<h3><a class="header" href="#stdtcp" id="stdtcp">@std/tcp**</a></h3>
<p>There should be a raw tcp client similar to the http client. Theoretically the http client could be built on top of this, but in reality that will not be the case (at first).</p>
<h3><a class="header" href="#stdudp" id="stdudp">@std/udp**</a></h3>
<p>Same.</p>
<h3><a class="header" href="#alantechpostgres" id="alantechpostgres">@alantech/postgres**</a></h3>
<p>A database client for postgres. Not sure if it should be part of the standard library or something that can be acquired from our github repo (and potentially eventually given to the Postgres organization?</p>
<p>Used by <code>datastore</code> as an implementation backend. Will we need to split the DHT-based implementation for <code>datastore</code> into another standard library?</p>
<h3><a class="header" href="#stdtest" id="stdtest">@std/test*</a></h3>
<p>Code for assertions and defining tests goes here. Need to decide on several conventions -- should it be &quot;spec&quot; files co-habiting with the source code, or in a separate &quot;test&quot; tree? All of my assumptions so far have been on the latter, as the mock pattern possible via the dependency importing depends on it.</p>
<p>Beyond that, the structure of the tests themselves are next. Assertions should be clearly declared, but should it be simple unit-test style list-of-functions-to-execute with basic assertion calls, or BDD-style &quot;describe-it-should&quot; style with &quot;english-looking&quot; assertion statements?</p>
<h3><a class="header" href="#stdfs-andor-stdposixfs--stdwinfs--stdclusterfs-" id="stdfs-andor-stdposixfs--stdwinfs--stdclusterfs-">@std/fs and/or @std/posixfs + @std/winfs + @std/clusterfs **</a></h3>
<p>We need a standard way to access and manipulate the filesystem for the OSS version of the language. Most languages don't give a shit about Windows' insanity in the filesystem layer and it bites them in the ass later when they have to get code written for one to work on the other. We could make <code>@std/fs</code> a simplified interface that builds on top of <code>@std/posixfs</code>, <code>@std/winfs</code>, and <code>@std/clusterfs</code> (the latter for the SaaS offering) which would have more specific capabilities for their respective platforms (at the end of the day, filesystems are basically shared hierarchical databases without transactions, so it's pretty simple to simulate one on a DHT).</p>
<h3><a class="header" href="#stdcsv" id="stdcsv">@std/csv**</a></h3>
<p>That which is dead can never die. Something to convert CSV files into an Array of user-defined types (or even more simply as an array of array of strings) is useful for anyone needing to work with that data, which is a trivial export format from Google Sheets, Excel, etc, and therefore a common interchange format.</p>
<h3><a class="header" href="#stdjson" id="stdjson">@std/json*</a></h3>
<p>This would include an interface, perhaps called <code>JSONish</code> that declares all JSON-ish types are those with <code>fn toJSON(JSONish): string</code> and <code>fn fromJSON(string): JSONish</code> as the required functions. Objects would be <code>Map&lt;string, JSONish&gt;</code>, Arrays would be <code>Array&lt;JSONish&gt;</code>. <code>int8</code>, <code>int16</code>, <code>int32</code>, and <code>float32</code>, <code>float64</code> would be the allowed JSON-ish numeric types. <code>bool</code> the allowed JSON-ish boolean type, <code>string</code> the allowed JSON-ish string type, and <code>void</code> the JSON-ish null type.</p>
<p>Other types <em>could</em> be added by the user, but because <code>fromJSON</code> would likely never reconstruct them, it would be a one-way conversion (eg, converting a <code>DateTime</code> object into JSON could become an object with the relevant fields or a unix timestamp or etc, but there's no way for <code>fromJSON</code> to know that particular field should be anything other than a <code>Map</code> or <code>int32</code>).</p>
<h3><a class="header" href="#stdxml" id="stdxml">@std/xml***</a></h3>
<p>While much less relevant nowadays, being able to parse XML is useful, and could <em>potentially</em> be used as the support structure for HTML parse and generation (but there was only a brief window where making HTML conformant to the XML spec was considered, and both early and modern HTML are not strictly so, meaning it might not be useful).</p>
<p>A big question is whether to include any support for the various XML validation standards (DTD, RelaxNG, etc). There were 4 major ones as I recall and I don't think a single one actually won out, but I do think the most primitive DTD ended up with the greatest share, when validation was used at all.</p>
<h3><a class="header" href="#stdhtml" id="stdhtml">@std/html***</a></h3>
<p>Constructing HTML should be relatively straightforward (it could have a DOM-like API and generate XML-compliant HTML) while parsing HTML would require mimicking decades of quirks the browsers support. :/</p>
<p>It still seems useful for a goal of kicking Node to the curb, and if done better than Node (which has never officially supported it) it might attract devs who aren't even interested in any of the value props of Alan.</p>
<p>We might also be able to, ah, borrow, Mozilla's Rust implementation here, since the Servo project has built one.</p>
<h3><a class="header" href="#stdcss" id="stdcss">@std/css***</a></h3>
<p>Similarly a solid way to parse and represent CSS seems like a good idea for taking dev mindshare. It would be therefore relatively simple to both include a mechanism for importing SASS and other CSS-like files and converting them to CSS, as well as making it irrelevant within Alan itself by making programmatic declaration of CSS rules simpler.</p>
<h3><a class="header" href="#stdzlib" id="stdzlib">@std/zlib***</a></h3>
<p>If we're generating custom HTML and CSS data, we probably want a way to compress it in the industry standard zlib/gzip format. We probably also don't want anyone implementing that in Alan itself, as the algorithm likely has looping, so providing a built-in way to compress and decompress this data is required.</p>
<h3><a class="header" href="#stdbz2" id="stdbz2">@std/bz2***</a></h3>
<p>Another common format, often on Unix machines.</p>
<h3><a class="header" href="#stdlzma" id="stdlzma">@std/lzma***</a></h3>
<p>Another common format, but very old. If it's not hard to include a library that does this, it seems reasonable.</p>
<h3><a class="header" href="#stdbase64" id="stdbase64">@std/base64**</a></h3>
<p>This should be simple to write even in alan itself to convert back and forth between a <code>string</code> and an <code>Array&lt;int8&gt;</code>.</p>
<h3><a class="header" href="#stdhash" id="stdhash">@std/hash**</a></h3>
<p>Getting access to non-cryptographic hash functions seems valuable. Perhaps this should also have UUID generation in here? I'm not sure where to place that and random number generation.</p>
<h3><a class="header" href="#stdssl" id="stdssl">@std/ssl***</a></h3>
<p>This should be a wrapper around https://www.libressl.org/ IMO. It could be around OpenSSL, but I seriously don't trust that project after the heartbleed stuff. The OpenBSD guys are also super sharp and the licensing means we can definitely just embed it into our project.</p>
<p>A secondary question: should we also expose <code>libcrypto</code> and <code>libtls</code> from their project?</p>
<h3><a class="header" href="#alantechauth" id="alantechauth">@alantech/auth***</a></h3>
<p>A generic authentication and authorization library. It's a bit opinionated to have one, but so many projects need it it's probably a good idea to provide a bit of opinion here. The question is do we mimic the POSIX model, OpenLDAP/ActiveDirectory, etc with a Role-Based Access Control https://en.wikipedia.org/wiki/Role-based_access_control or do we go extra opinionated and go with an Attribute-Based Access Control https://en.wikipedia.org/wiki/Attribute-based_access_control (which I personally like, but the only examples of its implementation is a weird XML standard, the US Government, and as a special mode in Windows Server 2012).</p>
<h3><a class="header" href="#stdinternationalization-or-stdi18n" id="stdinternationalization-or-stdi18n">@std/internationalization or @std/i18n***</a></h3>
<p>Simple tools for managing localization of text for different regions. There are lots of aspects here involving language selection (<code>en</code>), country-specific language dialect selection (<code>en_US</code>), numeric data representation (and pluralization), date and time formatting, currency formatting, etc.</p>
<p>I've done some of this work before, but I feel it needs a lot of thought to get right. Baking it into the standard library feels justified to me with greater and greater numbers of companies and people interacting internationally.</p>
<h3><a class="header" href="#alantechgraphql" id="alantechgraphql">@alantech/graphql***</a></h3>
<p>I hate making this suggestion, but front-end devs <em>love</em> GraphQL, and alan is uniquely positioned to be able to handle wild GraphQL queries efficiently and potentially with minimal impedance mismatch between the code you write and the GraphQL API you support (but we have to write logic to automatically generate a GraphQL schema for the registered queries and mutations, and it's not going to <em>perfectly</em> fit). It could be a great selling point coupled with <code>@std/datastore</code> for turn-key backends.</p>
<p>I can see a lot of value having it in the standard library so devs can use it immediately, but I also want to jettison this thing the moment the frontend world gets tired of this shitty fad (at least I hope its a fad).</p>
<h3><a class="header" href="#alantechoauth2" id="alantechoauth2">@alantech/oauth2***</a></h3>
<p>Similar logic here, being able to run an OAuth2 client and server is kinda gnarly and crappy, and having a built-in library that handles that mess for you would make things easier.</p>
<h1><a class="header" href="#examples-with-explanations" id="examples-with-explanations">Examples with Explanations</a></h1>
<p>In this section, several examples will be demonstrated with the <code>alan</code> language. Some of them will be repetitious, showing multiple ways to accomplish the same thing.</p>
<p>Attempting to force a single way to do things, as Python pushes for, can make things easy things easier, but breaking those patterns to be more concise in a particular problem domain can raise the actual clarity of what is happening and why for those working on it, and is why all fields of endeavour develop their own terminology and notation over time.</p>
<p><code>alan</code> attempts to make these situations clearer by requiring the explicit declaration of the notation in use so people new to the notation can read that mapping and understand what's going on better.</p>
<h2><a class="header" href="#the-many-forms-of-hello-world" id="the-many-forms-of-hello-world">The Many Forms of 'Hello, World!'</a></h2>
<p>The classic &quot;Hello, World!&quot; examples are a simple way to understand the minimum of structure you need to have in any code you write in a given language, with Java being famously heavyweight and Python famously featherweight.</p>
<p><code>alan</code> is in the middle, requiring some concepts from the get-go that would be confusing to absolute beginners, but not requiring as many concepts as Java.</p>
<h3><a class="header" href="#hello_world_1ln" id="hello_world_1ln"><code>hello_world_1.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">import @std/app

on app.start {
  app.print(&quot;Hello, World!&quot;)
  emit app.exit 0
}
</code></pre></pre>
<p>The first line imports the <code>app</code> export scope, which can be used like a user type.</p>
<p>The next (non-blank) line declares that &quot;on application start do this&quot;, which is relatively clear and analogous to C's <code>int main()</code> but slightly more English-y.</p>
<p>After that, &quot;the application prints 'Hello, World!'&quot; which is straightforward and what we're here to do.</p>
<p>Finally, &quot;emit application exit zero&quot; isn't super clear, but for those familiar with other &quot;Hello, World!&quot; type applications, it just looks like a funny <code>return 0</code>.</p>
<h3><a class="header" href="#hello_world_2ln" id="hello_world_2ln"><code>hello_world_2.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

on start {
  print(&quot;Hello, World!&quot;)
  emit exit 0
}
</code></pre></pre>
<p>Almost identical to the first, but it pulls the pieces of the <code>app</code> namespace into the module's namespace, so it's a good introduction to the <code>from foo import bar, baz, ...</code> syntax, what it does and why you might want it.</p>
<h3><a class="header" href="#hello_world_3ln" id="hello_world_3ln"><code>hello_world_3.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print as put, exit

on start {
  put(&quot;Hello, World!&quot;)
  emit exit 0
}
</code></pre></pre>
<p>This example demonstrates the renaming syntax on import, so you can choose a name that is clearer to you.</p>
<h3><a class="header" href="#hello_world_4ln" id="hello_world_4ln"><code>hello_world_4.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">import @std/app as program

on program.start {
  program.print(&quot;Hello, World!&quot;)
  emit program.exit 0
}
</code></pre></pre>
<p>Same as the previous, but the renaming is applied to the module name, rather than its contents.</p>
<h3><a class="header" href="#hello_world_5ln" id="hello_world_5ln"><code>hello_world_5.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

const helloWorld: string = &quot;Hello, World!&quot;

on start {
  print(helloWorld)
  emit exit 0
}
</code></pre></pre>
<p>This example demonstrates printing a variable instead of an inline constant.</p>
<h3><a class="header" href="#hello_world_6ln" id="hello_world_6ln"><code>hello_world_6.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, exit, print

on start fn {
  const hello: string = &quot;Hello&quot;
  const world: string = &quot;World&quot;
  print(concat(hello, &quot;, &quot;, world, &quot;!&quot;))
  emit exit 0
}
</code></pre></pre>
<p>This example demonstrates how values can be combined together to produce the desired result.</p>
<h3><a class="header" href="#hello_world_7ln" id="hello_world_7ln"><code>hello_world_7.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

on start {
  &quot;Hello, World!&quot;.print()
  emit exit 0
}
</code></pre></pre>
<p>This demonstrates the &quot;method-style&quot; function call syntax, which allows those who prefer OO development to have that style (though it could be misleading that it implies everything is an object, when it's really syntactic sugar, but...)</p>
<h3><a class="header" href="#hello_world_8ln" id="hello_world_8ln"><code>hello_world_8.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

fn main() {
  &quot;Hello, World!&quot;.print()
  emit exit 0
}

on start main
</code></pre></pre>
<p>This example demonstrates that the functions passed to an event handler don't have to be inline declared.</p>
<h3><a class="header" href="#hello_world_9ln" id="hello_world_9ln"><code>hello_world_9.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

prefix $&gt; 1 print

on start {
  _ = $&gt; &quot;Hello, World!&quot;
  emit exit 0
}
</code></pre></pre>
<p>This example introduces the <code>_</code> special variable and prefix operators, effectively renaming <code>print</code> to <code>$&gt;</code> and letting you print &quot;Hello, World!&quot; with another syntax.</p>
<p>Because the statement would be ambiguous otherwise, the operator expression <em>must</em> be assigned to something. Since we don't care what value <code>print</code> returns (hint: <code>void</code>), we assign to the <code>_</code> variable to throw it away.</p>
<h2><a class="header" href="#more-advanced-examples" id="more-advanced-examples">More advanced examples</a></h2>
<p>These examples are still relatively simple (they fit in a single file) but they demonstrate more concepts that cannot be easily shown in just a &quot;Hello, World!&quot; application.</p>
<h3><a class="header" href="#mathln" id="mathln"><code>math.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

on start fn {
  print(concat(&quot;1 + 2 = &quot;, toString(1 + 2)))
  print(concat(&quot;1 - 2 = &quot;, toString(1 - 2)))
  print(concat(&quot;1 * 2 = &quot;, toString(1 * 2)))
  print(concat(&quot;1 / 2 = &quot;, toString(1.0 / 2.0)))
  print(concat(&quot;1 % 2 = &quot;, toString(1 % 2)))
  print(concat(&quot;1 ** 2 = &quot;, toString(1 ** 2)))
  print(concat(&quot;1 &amp; 2 = &quot;, toString(1 &amp; 2)))
  print(concat(&quot;1 | 2 = &quot;, toString(1 | 2)))
  print(concat(&quot;1 ^ 2 = &quot;, toString(1 ^ 2)))
  print(concat(&quot;!1 = &quot;, toString(!1)))
  print(concat(&quot;1 !&amp; 2 = &quot;, toString(1 !&amp; 2)))
  print(concat(&quot;1 !| 2 = &quot;, toString(1 !| 2)))
  print(concat(&quot;1 !^ 2 = &quot;, toString(1 !^ 2)))
  print(concat(&quot;1 + 2 * 3 ** 4 = &quot;, toString(1 + 2 * 3 ** 4)))

  emit exit 0
}
</code></pre></pre>
<p>This example shows multiple math operations and their results, with the last statement demonstrating the order of operations effectively inverting the computational flow of that statement.</p>
<h3><a class="header" href="#object_literalsln" id="object_literalsln"><code>object_literals.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

type MyType {
  foo: string
  bar: bool
}

on start {
  print(&quot;Custom type assignment&quot;)
  const test = new MyType {
    foo = &quot;foo!&quot;
    bar = true
  }
  print(test.foo)
  print(test.bar)

  let test2 = new MyType {
    foo = &quot;foo2&quot;
    bar = true
  }
  test2.bar = false
  print(test2.foo)
  print(test2.bar)

  print(&quot;Array literal assignment&quot;)
  const test3 = new Array&lt;int64&gt; [ 1, 2, 4, 8, 16, 32, 64 ]
  print(test3[0])
  print(test3[1])
  print(test3[2])

  let test4 = new Array&lt;int64&gt; [ 0, 1, 2, 3 ]
  test4[0] = 1
  print(test4[0])

  print(&quot;Map literal assignment&quot;)
  const test5 = new Map&lt;bool, int64&gt; {
    true: 1
    false: 0
  }

  print(test5[true])
  print(test5[false])

  let test6 = new Map&lt;string, string&gt; {
    &quot;foo&quot;: &quot;bar&quot;
  }
  test6[&quot;foo&quot;] = &quot;baz&quot;
  print(test6[&quot;foo&quot;])

  emit exit 0
}
</code></pre></pre>
<p>This example demonstrates the three (so far) object literal syntaxes and sub-value accessor syntaxes.</p>
<h3><a class="header" href="#ifln" id="ifln"><code>if.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

fn bar() {
  print(&quot;bar!&quot;)
}

fn baz() {
  print(&quot;baz!&quot;)
}

fn nearOrFar(distance: float64): string {
  if distance &lt; 5.0 {
    return &quot;Near!&quot;
  } else {
    return &quot;Far!&quot;
  }
}

on start {
  if 1 == 0 {
    print(&quot;What!?&quot;)
  } else {
    print(&quot;The world is sane...&quot;)
  }

  if 1 == 0 {
    print(&quot;Not this again...&quot;)
  } else if 1 == 2 {
    print(&quot;Still wrong...&quot;)
  } else {
    print(&quot;The world is still sane, for now...&quot;)
  }

  const foo: bool = true
  if foo bar else baz

  print(nearOrFar(3.14))
  print(nearOrFar(6.28))

  const options = pair(2, 4)
  print(options[0])
  print(options[1])

  const options2 = 3 : 5
  print(options2[0])
  print(options2[1])

  const val1 = 1 == 1 ? 1 : 2
  const val2 = 1 == 0 ? 1 : 2
  print(val1)
  print(val2)

  const val3 = cond(1 == 1, pair(3, 4))
  const val4 = cond(1 == 0, pair(3, 4))
  print(val3)
  print(val4)

  const val5 = 1 == 0 ? options2
  print(val5)

  emit exit 0
}
</code></pre></pre>
<p>This example demonstrates conditionals (if statements) and shows that the conditional &quot;scopes&quot; are actually functions, but due to how nested scope rules work, they can still manipulate the parent function scope as needed for execution to function. It also demonstrates &quot;ternary&quot; operators and how they are composed of <code>pair</code> and <code>cond</code> function calls.</p>
<h3><a class="header" href="#datetimeln" id="datetimeln"><code>datetime.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import print

export type Year {
  year: int32
}

export type YearMonth {
  year: int32
  month: int8
}

export type Date {
  year: int32
  month: int8
  day: int8
}

export type Hour {
  hour: int8
}

export type HourMinute {
  hour: int8
  minute: int8
}

export type Time {
  hour: int8
  minute: int8
  second: float64
}

export type DateTime {
  date: Date
  time: Time
  timezone: HourMinute
}

export fn makeYear(year: int32): Year {
  return new Year {
    year = year
  }
}

export fn makeYear(year: int64): Year {
  return new Year {
    year = toInt32(year)
  }
}

export fn makeYearMonth(year: int32, month: int8): YearMonth {
  return new YearMonth {
    year = year
    month = month
  }
}

export fn makeYearMonth(y: Year, month: int64): YearMonth {
  return new YearMonth {
    year = y.year
    month = toInt8(month)
  }
}

export fn makeDate(year: int32, month: int8, day: int8): Date {
  return new Date {
    year = year
    month = month
    day = day
  }
}

export fn makeDate(ym: YearMonth, day: int64): Date {
  return new Date {
    year = ym.year
    month = ym.month
    day = toInt8(day)
  }
}

export fn makeHour(hour: int8): Hour {
  return new Hour {
    hour = hour
  }
}

export fn makeHourMinute(hour: int8, minute: int8): HourMinute {
  return new HourMinute {
    hour = hour
    minute = minute
  }
}

export fn makeHourMinute(hour: int64, minute: int64): HourMinute {
  return new HourMinute {
    hour = toInt8(hour)
    minute = toInt8(minute)
  }
}

export fn makeHourMinute(h: Hour, minute: int8): HourMinute {
  return new HourMinute {
    hour = h.hour
    minute = minute
  }
}

export fn makeTime(hour: int8, minute: int8, second: float64): Time {
  return new Time {
    hour = hour
    minute = minute
    second = second
  }
}

export fn makeTime(hm: HourMinute, second: float64): Time {
  return new Time {
    hour = hm.hour
    minute = hm.minute
    second = second
  }
}

export fn makeTime(hm: HourMinute, second: int64): Time {
  return new Time {
    hour = hm.hour
    minute = hm.minute
    second = toFloat64(second)
  }
}

export fn makeDateTime(date: Date, time: Time, timezone: HourMinute): DateTime {
  return new DateTime {
    date = date
    time = time
    timezone = timezone
  }
}

export fn makeDateTime(date: Date, time: Time): DateTime {
  return new DateTime {
    date = date
    time = time
  }
}

export fn makeDateTimeTimezone(dt: DateTime, timezone: HourMinute): DateTime {
  return new DateTime {
    date = dt.date
    time = dt.time
    timezone = timezone
  }
}

export fn makeDateTimeTimezoneRev(dt: DateTime, timezone: HourMinute): DateTime {
  return new DateTime {
    date = dt.date
    time = dt.time
    timezone = new HourMinute {
      hour = -timezone.hour
      minute = timezone.minute
    }
  }
}

export fn print(dt: DateTime) {
  // TODO: Work on formatting stuff
  let timezoneOffsetSymbol: string
  if (dt.timezone.hour &lt; toInt8(0)) {
    timezoneOffsetSymbol = &quot;-&quot;
  } else {
    timezoneOffsetSymbol = &quot;+&quot;
  }
  let str: string = concat(
    toString(dt.date.year), &quot;-&quot;, toString(dt.date.month), &quot;-&quot;, toString(dt.date.day), &quot;@&quot;,
    toString(dt.time.hour), &quot;:&quot;, toString(dt.time.minute), &quot;:&quot;, toString(dt.time.second),
    timezoneOffsetSymbol, abs(dt.timezone.hour).toString(), &quot;:&quot;, dt.timezone.minute.toString()
  )
  print(str)
}

export prefix # 2 makeYear

export infix - 2 makeYearMonth

export infix - 2 makeDate

export infix : 3 makeHourMinute

export infix : 3 makeTime

export infix @ 2 makeDateTime

export infix + 2 makeDateTimeTimezone

export infix - 2 makeDateTimeTimezoneRev
</code></pre></pre>
<p>This more complex example defines a simplistic DateTime type and associated types, as well as various constructor functions and mappings of those onto operators.</p>
<h3><a class="header" href="#test_datetimeln" id="test_datetimeln"><code>test_datetime.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, exit

from ./datetime import DateTime, print, #, -, :, @, +

on start fn {
  const dt: DateTime = #2020-01-15@09:45:00-08:00
  print(dt)
  emit exit 0
}
</code></pre></pre>
<p>This file uses the <code>datetime.ln</code> file to very concisely define a time in ISO format and then print it out. It is a demonstration of how operators can be used to create compact-but-clear DSLs where you can still go to the source code to find out how and why it works.</p>
<h3><a class="header" href="#methodln" id="methodln"><code>method.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

from ./datetime import DateTime, print, #, -, :, @, +

on start fn {
  true.print()
  1.print()
  3.14159.print()
  &quot;Hello, World!&quot;.print()

  const dt: DateTime = #2020-01-17@16:15:00-08:00
  dt.print()

  print(3.add(2))
  3.add(2).print()
  (3 + 2).print()

  emit exit 0
}
</code></pre></pre>
<p>This example introduces method syntax, and shows multiple variants of the same statement at the end.</p>
<h3><a class="header" href="#stringln" id="stringln"><code>string.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

on start fn {
  const helloWorld: string = &quot;Hello, &quot; + &quot;World!&quot;
  print(helloWorld)

  const helloWorldArr: Array&lt;string&gt; = helloWorld / &quot;, &quot;
  print(helloWorldArr[0])
  print(helloWorldArr[1])

  const helloWorldArr2: Array&lt;string&gt; = helloWorld.split(&quot;, &quot;)
  print(helloWorldArr2[0])
  print(helloWorldArr2[1])

  const helloWorldMap = new Map&lt;string, string&gt; {
    &quot;hello&quot;: &quot;Hello&quot;
    &quot;world&quot;: &quot;World&quot;
  }
  print(template(&quot;${hello}, ${world}!&quot;, helloWorldMap))
  print(&quot;${hello}, ${world}!&quot; % helloWorldMap)

  print(&quot;Hi &quot; * 5)
  print(repeat(&quot;Hi &quot;, 5))

  print(helloWorld ~ &quot;or&quot;) // Java's regex engine is whack, this returns false, replace with PCRE
  print(helloWorld.matches(&quot;or&quot;))

  print(helloWorld @ &quot;or&quot;)
  helloWorld.index(&quot;or&quot;).print()

  print(#helloWorld)
  print(length(helloWorld))
  print(helloWorld.length())
  helloWorld.length().print()

  print(&quot;'&quot; + `(&quot;Hi &quot; * 5) + &quot;'&quot;)
  print(concat(&quot;'&quot;, trim(repeat(&quot;Hi &quot;, 5)), &quot;'&quot;))

  emit exit 0
}
</code></pre></pre>
<p>This example exercises many string manipulation mechanisms and alternate syntaxes using operators and method style function calls.</p>
<h3><a class="header" href="#typeofln" id="typeofln"><code>typeof.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

type foo&lt;A, B&gt; {
  bar: A
  baz: B
}

type foo2 = foo&lt;int64, float64&gt;

on start fn {
  print(type 3)
  print(type 3.14)
  print(type (1 + 2))
  print(type &quot;str&quot;)
  print(type true)
  print(type true == &quot;bool&quot;)
  
  let a: foo&lt;string, int64&gt;
  let b: foo&lt;int64, bool&gt;
  let c: foo2
  let d: foo&lt;int64, float64&gt;
  print(type a)
  print(type b)
  print(type type a)
  print(type c)
  print(type d)
  print(type c == type d)

  emit exit 0
}
</code></pre></pre>
<p>This example demonstrates acquiring the type of constants and variables, as well as the basics of generic types.</p>
<h3><a class="header" href="#boxln" id="boxln"><code>box.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

type box&lt;V&gt; {
  set: bool
  val: V
}

on start fn {
  let int8Box: box&lt;int8&gt;
  int8Box.val = 8
  int8Box.set = true
  print(int8Box.val)
  print(int8Box.set)

  let stringBox: box&lt;string&gt;
  stringBox.val = &quot;hello, generics!&quot;
  stringBox.set = true
  print(stringBox.val)
  print(stringBox.set)

  const stringBoxBox = new box&lt;box&lt;string&gt;&gt; {
    val = new box&lt;string&gt; {
      val = &quot;hello, nested generics!&quot;
      set = true
    }
    set = true
  }
  stringBoxBox.set.print()
  stringBoxBox.val.set.print()
  stringBoxBox.val.val.print()

  // The following should crash, later will be a compile-time error
  stringBox.val = 8

  emit exit 0
}
</code></pre></pre>
<p>This example uses generics to define a Box type and how to work with it at a basic assignment level.</p>
<h3><a class="header" href="#big_loopln" id="big_loopln"><code>big_loop.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">from @std/app import start, print, exit

event loop: int64

on loop fn looper(val: int64) {
  print(val)
  if val &gt;= 1000000 {
    emit exit 0
  } else {
    emit loop val + 1
  }
}

on start {
  emit loop 0
}
</code></pre></pre>
<p>This example defines a custom event type and then uses it to implement a recursive function that prints to 1 million and then quits. It also usesif statements to accomplish this.</p>
<p>This is slow and intentionally awkward because this is an escape hatch to Turing-completeness and not the intended primary use case, as <code>alan</code>'s execution planner will not be able to properly optimize the parallelization of this approach (it is by definition a sequential operation, though the body of the recursive function may be parallelized). It shouldn't be necessary to accomplish your needs in the language, but it is there.</p>
<h3><a class="header" href="#httpln" id="httpln"><code>http.ln</code></a></h3>
<pre><pre class="playpen"><code class="language-rust editable">import @std/http

on http.port(8080) fn (socket: http.Socket) {
  socket.response.statusCode = 200
  socket.response.body = &quot;Hello, World!&quot;
  http.close(socket)
}
</code></pre></pre>
<p>This example defines a <code>Hello, World!</code> http server on port 8080.</p>

            </main>

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                

                

                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
        

        
    </nav>

</div>



<!-- Analytics Tag -->
<script type="text/javascript">
    var localAddrs = ["localhost", "127.0.0.1", ""];

    // make sure we don't activate analytics if the developer is
    // inspecting the book locally...
    if (localAddrs.indexOf(document.location.hostname) === -1) {
        !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on","addSourceMiddleware","addIntegrationMiddleware","setAnonymousId","addDestinationMiddleware"];analytics.factory=function(e){return function(){var t=Array.prototype.slice.call(arguments);t.unshift(e);analytics.push(t);return analytics}};for(var e=0;e<analytics.methods.length;e++){var t=analytics.methods[e];analytics[t]=analytics.factory(t)}analytics.load=function(e,t){var n=document.createElement("script");n.type="text/javascript";n.async=!0;n.src="https://cdn.segment.com/analytics.js/v1/"+e+"/analytics.min.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(n,a);analytics._loadOptions=t};analytics.SNIPPET_VERSION="4.1.0";
            analytics.load("fGya8GY5wLqdnLzyXnGM2HjYglPszWS0");
            analytics.page("Docs", );
        }}();
    }
</script>


    <script type="text/javascript">
        window.playpen_line_numbers = true;
    </script>



    <script type="text/javascript">
        window.playpen_copyable = true;
    </script>



    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>



    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>


<!-- Custom JS scripts -->

    <script type="text/javascript" src="bundle.js"></script>

    <script type="text/javascript" src="theme-solarized_dark.js"></script>

    <script type="text/javascript" src="theme-solarized_light.js"></script>


<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

</body>
</html>
